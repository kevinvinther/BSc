\documentclass{report}

\usepackage[a4paper]{geometry} % paper size, margins etc.

\usepackage{tlatex}
\usepackage{listings}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{lipsum}

\usepackage[most]{tcolorbox}
\usepackage{fontawesome}
\usepackage{xcolor}
\usepackage{enumitem} % Add the possibility of removing indentation in enumerate
\usepackage{multicol}

\usepackage{algorithm2e}

\definecolor{mycolor}{RGB}{242,87,87}
\definecolor{green}{RGB}{123, 224, 173}
\definecolor{yellow}{RGB}{255, 220, 94}
\definecolor{offwhite}{RGB}{248,236,224}
\newcommand*{\sans}{\fontfamily{lmss}\selectfont}

\newtcolorbox{callout}{
  enhanced,
  colback=mycolor,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutgreen}{
  enhanced,
  colback=green,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutyellow}{
  enhanced,
  colback=yellow,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}



\begin{titlepage}
  \centering
       \vspace*{1cm}
       \textbf{Formal Verification of Distributed Leader Election Algorithms with Model Checking}\\
       \vspace{0.4cm}
       June 1, 2023

       \vspace{0.5cm}

       \vspace{1.5cm}

       \begin{multicols}{2}
       Student\\
       \textbf{Kevin Joshua Vinther}\\
       \textit{kevin20@student.sdu.dk}
       \vspace{0.5cm}
       \\
       Supervisor\\
       \textbf{Marco Peressotti}\\
       \textit{Peressotti@imada.sdu.dk}
       \end{multicols}


       \vfill

       \vspace{0.8cm}

\end{titlepage}
\begin{document}

\tableofcontents

\chapter{Introduction}
\begin{callout}
  TODO: Confidence 0/10:

  What is the significance of Leader Election? What is the significance of TLA+? What do you solve?
\end{callout}

\chapter{Overview}
\begin{callout}
TODO: Confidence 1/10
\end{callout}

This is the main body section.

\section{Leader Election}
\begin{callout}
TODO: Confidence 3/10
\end{callout}

In several algorithms for distributed systems, a process may posses the role of the \textit{leader}. A leader may be required in a system because algorithms typically are not completely symmetrical, and thus the leader can take the lead in initiating the algorithm. \cite{kshemkalyani2011distributed}

The aim of a leader election algorithm, thus, is to elect a leader from a set of processes. If this leader dies, it is the algorithms job to find a new leader.

This \textit{report?} will search to implement two leader election algorithms: The \textit{Bully Algorithm} and the \textit{Ring Algorithm}\footnote{Also known as the Lelang, Chang and Roberts (LCR) algorithm, but commonly referred to as the Ring algorithm, as will be done in this \texit{report?}}

Both of the algorithms are algorithms that work on graphs. The Bully Algorithm's overlay is a complete, undirected graph, and the Ring Algorithm's overlay is a superimposed undirected ring, and a logical complete graph. Both algorithms assume that:
\begin{itemize}
  \item The network is reliable. Messages do not get lost.
  \item Nodes may fail at any time, including the leader.
  \item Fail-stop model. Failed nodes are removed from the system forever.
\end{itemize}


\section{Bully Algorithm}

The Bully Algorithm is an algorithm which solves the problem of leader election. The bully algorithm assumes a complete undirected graph.

The messages in the algorithm are:
\begin{itemize}
  \item \textit{election}: announce an election
  \item \textit{alive}: response to \textit{election}
  \item \textit{victory}: sent by winner to announce victory
\end{itemize}

When a process P recovers from failure, or the failure detector indicates that the current leader has failed, P performs the following actions:



\begin{enumerate}
\item If P has the highest process ID, it sends a Victory message to all other processes and becomes the new leader. Otherwise, P broadcasts an Election message to all other processes with higher process IDs than itself.
\item If P receives no alive after sending an Election message, then it broadcasts a Victory message to all other processes and becomes the leader.
\item If P receives an alive from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)
\item If P receives an Election message from another process with a lower ID it sends an alive message back and if it has not already started an election, it starts the election process at the beginning, by sending an Election message to higher-numbered processes.
\item If P receives a victory message, it treats the sender as the leader.
\end{enumerate}




\section{Ring Algorithm}

The Ring Algorithm solves the Leader ELection problem. However, unlike the Bully Algorithm, the Ring Algorithm assumes a superimposed undirected ring.

The messages in the Ring Algorithm are:
\begin{itemize}
  \item \textit{probe(id)}: search for the leader
  \item \textit{selected(id)}: announce the result
\end{itemize}

You will notice in the messages, that they have attached an \textit{id}. The \textit{id} is used to identify who originally sent the message.

Furthermore, the Ring Algorithm uses a \textit{boolean} variable, called \textit{participate}. This variable is required for the algorithm, and indicates whether or not process $P_{i}$ participates in the election.

\noindent
When process $P_{i}$ wakes up to participate in the election:
\begin{enumerate}
  \item Send \textit{probe(i)} to right neighbour
        \item \textit{participate } $\leftarrow $ \textsc{True}
\end{enumerate}

\noindent
When \textit{probe(k)} message arrives from the left neighbour $P_{j}$:
\begin{enumerate}
  \item If \textit{participate} = \textsc{False} then \textit{participate} $\leftarrow$ \textsc{True}.
  \item if $i > k$ then discard the probe
  \item else if $i < k$ then forward \textit{probe(k)} to right neighbor
  \item else if $i = k$ then declare $i$ is the leader; circulate \textit{selected(i)} to right neighbour;
\end{enumerate}

\noindent
When a \textit{selected(x)} message arrives from left neighbour:
\begin{enumerate}
  \item if $x \neq i$ then note $x$ as the leader and forward message to right neighbor
        \item else do not forward the \textit{selected} message.
\end{enumerate}
(\cite{kshemkalyani2011distributed})
\section{TLA+}
\begin{callout}
  write something about distributed systems
\end{callout}

TLA+ (Temporal Language of Actions Plus) is a language for modeling specifications, and widely used for proving algorithms. It has proven to be a very useful tool for proving algorithms, because of they way the language works, by forcing you to write mathematically correct implementations, that can be tested in every possible state.

\chapter{Bully Algorithm}

\section{Converting to TLA+}
Since we have based ourself on an instruction set rather than pseudocode for what process $p$ should do, it has been more a process of modelling the algorithm correctly, rather than converting it from pseudocode.

\subsection{Deviations from pseudocode}
The second point in the algorithm described earlier states that, if process $p$ receives no \textit{alive} message after sending an Election message, then it broadcasts an \textit{victory} message to all other processes. Since TLA$^{+}$ does not allow for waiting a specified amount of time, I have made a major modification to the algorithm. Instead of waiting to see, it immediately checks if process P is the process with the highest ID alive, and broadcasts a \textit{victory} message if this is the case. We allow ourself this because \textit{fail-stop model?} assumes that all processes will know the failure of other processes, but it is not specified how. Therefore, we can assume that the process will know that it is the highest process. This is also done in the beginning of the algorithm, when a process checks if a leader is dead. However, the rest of the implementation is as true to the pseudocode \textit{can I call it that?} as possible.

\section{Setup}

\begin{calloutgreen}
  Minor tweaks needed
\end{callout}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@pvspace{8.0pt}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} ProcessID \.{\times} \{\@w{ELECTION} ,\,\@w{ALIVE}
 ,\,\@w{VICTORY} \}}%
\@pvspace{8.0pt}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto}}%
\@x{\@s{109.06} [ ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\fl{}\bottombar\cl{}

\caption{Setup for the Bully Algorithm}
\label{bullysetup}
\end{figure}

Before modeling the behavior of the specification, we set up the constants, variables and types \textit{types? better explanation needed}. Looking at the specification for the algorithm, we need to model processes and messages.

The algorithm assumes a complete undirected graph. We model this by creating a \textbf{State} variable, which contains a record of all \textit{processes} and their fields. We define the \textbf{State} variable to be a sequence of records, each of which hold the following metadata in its fields:
\begin{itemize}
    \item \textit{ID}: The process has a unique ID. $ID \in ProcessID$, where $ProcessID$ is the total number of processes, defined as a range from 1 to the natural number N.
    \item \textit{Condition}: A process is either dead or alive (called \textit{active}). Due to the assumptions of the algorithm we assume that each process knows when another process is dead. Condition $\in$ \{{\sans"Dead", "Active"}\}
    \item \textit{Leader}: The process should know who it's leader is. The leader may be the process itself. $Leader \in ProcessID$
    \item \textit{Participating}: The process is either participating in the election or not. This information is only used for the process itself. $Participating \in$ {\small \textsc{Boolean}}
\end{itemize}
Furthermore, we define a sequence, \textbf{MessageBox} which holds every processes received messages. The MessageBox maps from each process, $p$ initially to an empty tuple, and later on to a sequence of tuples. These tuples are the \textbf{Message}s. We define a \textbf{Message} as ProcessID $\times$ \{{\sans ``ELECTION'', ``ALIVE'', ``VICTORY''}\}, thus an example of an {\sans ``ELECTION''} message from process $1$ is: $\langle1,$ {\sans ``ELECTION''} $\rangle$

\section{Sending Messages}


\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Sending Messages}\moduleRightDash\@xx{}%
\@x{ SendAlive ( p ,\, q ) \.{\defeq}}%
 \@x{\@s{16.4} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{ALIVE} {\rangle} ) ]}%
\@pvspace{16.0pt}%
\@x{ SendVictory ( p ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID
 \.{\mapsto}}%
 \@x{\@s{48.01} {\IF} q \.{\neq} p \.{\land} State [ q ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{48.01} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{VICTORY} {\rangle} )}%
\@x{\@s{48.01} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendElection ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{32.8} {\IF} q \.{\in} HigherIDs ( p ) \.{\land} State [ q ] .
 Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{ELECTION} {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%
\fl{}\bottombar\cl{}

\caption{The \textit{sender} functions}
\end{figure}

\begin{calloutyellow}
  Should this section maybe be after the explanation of handlers? I added a new function, that should be explained as well.
  \end{callout}

Along with the correct modeling of processes, the most important functionality in the algorithm is the sending, receiving and handling of messages.

We earlier defined the \textbf{MessageBox} to be a sequence of \textbf{Message}s. This makes the handling of messages extremely convenient. One of the core operations we make with messages are sending them. To send a message from process $p$ to process $q$ with the contents {\sans ELECTION}, we simply append the tuple $\langle p, $ {\sans ``ELECTION''} $\rangle$ to \textit{MessageBox[q]}. In TLA$^{+}$ this is done like so:
\begin{lstlisting}
MessageBox'
     = [MessageBox EXCEPT ![q] = Append(<<p, ''ELECTION''>>)]
\end{lstlisting}
This defines the MessageBox variable to have $\langle p, $ {\sans ``ELECTION''} $\rangle$ appended to \textit{MessageBox[q]} in the next state.

\begin{calloutyellow}
  In earlier section, maybe write about why we have modelled the messages liket his, rather than when using them? Why do we have sender e.g.
  \end{calloutyellow}

  As discussed earlier, there are three different messages in the bully algorithm: \textit{alive}, \textit{victory}, and \textit{election}.

The \textit{alive} message is only sent in a case where a process receives an \textit{election} message from a process with a lower id. Thus, no additional work is needed other than process $q$ should receive an \textit{alive} message from process $p$. This job is done by the \textit{SendAlive} function.

The \textit{SendVictory} function is similar, only it sends the \textit{victory} message to all processes except the sender. We assume a fail-stop model\footnote{In a fail-stop model, any functioning process may fail at any time, and any other processes can learn that the process has failed. (\cite{kshemkalyani2011distributed})}, meaning that the other processes learn when a process dies, allowing us to send only to the alive processes.
\begin{callout}
Why can't I just say $q \in (1..MaxAliveID $\textbackslash$ p)$?
\end{callout}

\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{MaxAliveID}\moduleRightDash\@xx{}%
\@xx{}%
\@x{ MaxAliveID \.{\defeq} {\CHOOSE} id \.{\in} ProcessID \.{:}}%
 \@x{\@s{80.15} \A\, p \.{\in} ProcessID \.{:} State [ p ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{163.18} \.{\lor} id \.{\geq} State [ p ] . ID}%
\fl{}\bottombar\cl{}

  \caption{Function that returns the highest ID alive}
  \end{figure}

\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{HigherIDs}\moduleRightDash\@xx{}%
 \@x{ HigherIDs ( p ) \.{\defeq} \{ q \.{\in} 1 \.{\dotdot} MaxAliveID \.{:} q
 \.{>} p \}}%
\fl{}\bottombar\cl{}
\label{higherids}
  \caption{Function which returns all IDs higher than $p$}
\end{figure}

Similar to the \textit{victory} message, the \textit{election} message is sent to a select group of processes. This time it's all processes with a higher ID than $p$. This is achieved using a helper function \textit{HigherIDs} (see figure \ref{higherids}.)

\section{Handling Received Messages}


\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Handle Received Messages}\moduleRightDash\@xx{}%

\@pvspace{8.0pt}%
 \@x{ ReceiveAlive ( p ,\, q ) \.{\defeq} \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
\@y{\@s{0}%
 Make sure they are already participating
}%
\@xx{}%
\@x{\@s{98.58} \.{\land} p \.{>} q}%
 \@x{\@s{98.58} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ]}%
\@y{\@s{0}%
 No longer participate
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ReceiveElection ( p ,\, q ) \.{\defeq}\@s{4.1} \.{\lor} \.{\land} p
 \.{=} MaxAliveID}%
\@x{\@s{126.95} \.{\land} SendVictoryAndTail ( p )}%
 \@x{\@s{126.95} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\,}%
\@x{\@s{244.46} {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{115.84} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
\@x{\@s{126.95} \.{\land} SendElectionAndAliveAndTail ( p ,\, q )}%
 \@x{\@s{126.95} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
 \@x{ ReceiveVictory ( p ,\, q ) \.{\defeq} State \.{'} \.{=} [ State
 {\EXCEPT} {\bang} [ p ] . Leader \.{=} q ]}%
\@y{\@s{0}%
 Set the leader of receiver to \ensuremath{p} sender
}%
\@xx{}%


\fl{}\bottombar\cl{}

\caption{Message Handlers}
\label{messagehandlers}
\end{figure}

\begin{calloutyellow}
Bad formulations. HandleMessages should probably be discussed first.
  \end{calloutyellow}

When a message is received, a process will periodically check the \textit{HandleMessages} function, which will then execute the correct functions depending on the message.

Points 3, 4, and 5 describe what to do when receiving messages:

\begin{calloutyellow}
Maybe make the pseudocode a figure and refer to that instead?
\end{calloutyellow}
\begin{enumerate}
  \setcounter{enumi}{2}
  \item If P receives an alive from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)
  \item If P receives an Election message from another process with a lower ID it sends an alive message back and if it has not already started an election, it starts the election process at the beginning, by sending an Election message to higher-numbered processes.
  \item If P receives a victory message, it treats the sender as the leader.
\end{enumerate}

The function \textit{ReceiveAlive} (see figure \ref{messagehandlers}) addresses point 3. The function does not need to check if the sender of the \textit{alive} message is alive, since any messages from dead processes are removed by the \textit{HandleMessages} function. Therefore, the only thing \textit{ReceiveAlive} does, is to check if the message is from a higher id than itself, and if so, it modifies it's participation status to be FALSE.

The function \textit{ReceiveElection} (Figure \ref{messagehandlers}) addresses point 4. Since we assume a fail-stop model, we can say that if $p$ is the process with the highest id alive, it can send a \textit{victory} message, and finish the election by declaring itself the leader. If this is not the case, it sends an \textit{election} message, and an \textit{alive} message to the process who sent $p$ the \textit{election} message.

The \textit{ReceiveVictory} function (Figure \ref{messagehandlers}) addresses point 5 by setting the leader to the sender of the \textit{victory} message.


\section{Delegating Functions with HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Delegate Messages}\moduleRightDash\@xx{}%
\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{93.62} sender \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{93.62} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{93.62} \.{\IN}}%
\@x{\@s{97.72} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{97.72} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{4.1}}%
\@y{\@s{0}%
 Message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{97.72} \.{\land} \.{\lor} \.{\land} State [ sender ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%
\@x{\@s{119.95} \.{\land} {\UNCHANGED} State}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{VICTORY}}%
\@y{\@s{0}%
 If the message is \ensuremath{VICTORY
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveVictory ( p ,\, sender )}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@y{\@s{0}%
 Remove all messages
}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ELECTION}}%
\@y{\@s{0}%
 If the message is \ensuremath{ELECTION
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveElection ( p ,\, sender )}%
\@y{\@s{0}%
 Tail is done incide \ensuremath{ReceiveElection
}}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ALIVE}}%
\@y{\@s{0}%
 If the message is \ensuremath{ALIVE
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveAlive ( p ,\, sender )}%
\@y{\@s{0}%
 Handle in \ensuremath{ReceiveAlive
}}%
\@xx{}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%

\fl{}\bottombar\cl{}

\caption{Delegating Functions}
\label{handlemessages}
\end{figure}

In the \textit{Next} predicate of the specification, one of the actions a process can take is to check its messages. This is done via the \textit{HandleMessages} function. If process $p$ has any messages in their inbox, one of 4 things can happen, depending on the type of message or the condition of the sender.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]
  \item If the sender is dead, we ignore the message and delete it from the inbox of process $p$.
  \item If the content of the message is {\sans ``VICTORY''}, we delegate work to the \textit{ReceiveVictory} function and remove all messages from process $p$ so that an endless election does not occur. If we don't remove all messages, it is likely a lot of \textit{election} messages are left behind, all of which will start a new election when a leader has just been found. \textbf{Should this be a footnote?}
  \item If the content of the message is {\sans ``ELECTION''}, we delegate the rest of the work to the \textit{ReceiveElection} function.
  \item If the content of the message is {\sans ``ALIVE''}, we delegate work to the \textit{ReceiveAlive} function and delete the message from the inbox of process $p$.
\end{enumerate}


\section{Checking the leader condition}

\begin{calloutgreen}
  Minor corrections needed.
  \end{calloutgreen}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{CheckLeader}\moduleRightDash\@xx{}%
 \@x{ CheckLeader ( p ) \.{\defeq}\@s{8.2} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{96.12} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{96.12} \.{\land} \.{\lor} \.{\land} p \.{=} MaxAliveID}%
\@x{\@s{118.35} \.{\land} SendVictory ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} p ]}%
\@x{\@s{107.24} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
\@x{\@s{118.35} \.{\land} SendElection ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%

\fl{}\bottombar\cl{}

\caption{Checking the condition of the leader}
\label{checkleader}
\end{figure}

One of the actions a process can take in the next state is to check the condition of the leader.
In the pseudocode, it is specified that ``When a process P recovers from failure, or the failure detector indicates that the current leader has failed...''. Since we assume that the processes do not recover from failure, and know that a process is dead, we use the \textit{CheckLeader} (Figure \ref{checkleader}) function instead.

The function only runs if the process checking is active, and the leader is dead. If this is the case, it checks whether process $p$ is the process with the highest id. If this is the case, $p$ sends a \textit{victory} message, and declares itself the victor. If $p$ is not the process with the highest id, it sends an \textit{election} message and sets itself to participate in the election.



\section{Next predicate and killing the leader}
\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{NextPredicateAndKillLeader}\moduleRightDash\@xx{}%

\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ,\, {\bang} [ MaxAliveID ] .
 Participating \.{=} {\FALSE} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 CheckLeader ( p ) \.{\lor} HandleMessages ( p )}%

\fl{}\bottombar\cl{}
\caption{Next predicate and KillLeader}
\label{nextpredkillleader}
\end{figure}

\begin{calloutgreen}
  Minor corrections needed, some formulations and maybe a bit too much explanation.
  \end{calloutgreen}

The Next predicate is the predicate which chooses what should happen in the next state.
For this specification there are two options. Either, the leader is killed, or a process handles it's messages or checks its leader's status.

In case the choice is made to kill the leader, we make sure that the leader sees itself as the leader, and if they do we change its condition in the next state to be dead and its participation status to be \textsc{False}, effectively killing it. This is only done if there are 2 or more processes alive.

In case the decision to kill the leader is not chosen, a process is chosen to either check it's leader or handle it's messages.


\section{Invariants and properties}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Invariants and Properties}\moduleRightDash\@xx{}%
\@x{}%
\@y{\@s{0}%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Each variable should be within the type constraints
}%
\@xx{}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Every process should have a unique \ensuremath{ID
}}%
\@xx{}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If a process is participating in the election, then it should not be the
 leader
}%
\@xx{}%
 \@x{ Participating \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{=} {\TRUE} \.{\implies} State [ p ] . Leader \.{\neq} p}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{\@s{0}%
 Properties
}%
\@xx{}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{16.0pt}%
\@x{}%
\@y{\@s{0}%
 The highest alive process should become the leader
}%
\@xx{}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{16.4} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} ( {\Diamond} ( State [ p ] . Participating \.{=}
 {\FALSE} ) )}%
\@pvspace{16.0pt}%
\@x{}\bottombar\@xx{}%

  \caption{Invariants and Properties in the Bully Algorithm}
  \label{bullyinvariantsproperties}
  \end{figure}

\textbf{Invariants}\\
\noindent
In TLA$^{+}$, an \textit{invariant} is a statement that must be true on every state of the program\cite{https://learntla.com/core/invariants.html}. One common type of invariant is the \textit{TypeOK} invariant (Figure \ref{bullyinvariantsproperties}). \textit{TypeOK} makes sure that the types never go out of a specified domain or change to an unwanted value. In the case of this specification this is true for the \textit{State} and \textit{MessageBox} variables. For the \textit{State} variable, it will hold true that:
\begin{itemize}
  \item A process' \textit{id} is a part of the \textit{ProcessID}\footnote{See figure \ref{bullysetup} for the definition of ProcessID} set
  \item A process' condition is either \textit{Active} or \textit{Dead}
  \item A process' \textit{leader} is a part of the \textit{ProcessID} set
  \item A process' participation status is a \textsc{Boolean}
\end{itemize}
For the message box it holds that each ID will map to a sequence of messages\footnote{See figure \ref{bullysetup} for the defintion of Message}.

In this specification, we also have an invariant called \textit{UniqueID} which makes sure that no two processes hold the same ID. Furthermore, we also have an invariant called \textit{Participating} which states that, if a process is participating in an election, it cannot be the leader itself, or see itself as leader.

\\\\
\noindent
\textbf{Properties}\\
\noindent
There are two kinds of temporal properties: safety properties, and liveness properties. Safety properties make sure that the system doesn't do bad things, and liveness makes sure our system always does a good thing.\cite{https://learntla.com/core/temporal-logic.html}

We have three properties: two safety properties and one liveness property. The safety properties are \textit{ElectionTerminationImpliesSameLeader}, and \textit{HighestAliveProcessIsLeader}. \textit{ElectionTerminationImpliesSameLeader} ensures that when two processes that have been in an election eventually get out of the election, they will have the same leader. \textit{HighestAliveProcessIsLeader} ensures that if a process is not participating in an election, it's leader is the process with the highest id alive.

The liveness property, \textit{ElectionWillEnd} ensures that an election will eventually end.



\chapter{Ring Algorithm}


\section{Similarities to Bully Algorithm}
The Ring Algorithm and the Bully Algorithm are both similar in many ways. One similarity which carries over from our implementation of the Bully Algorithm to the Ring Algorithm is the modeling of the graphs. Since the Ring Algorithm is also an algorithm on graphs, we can reuse a lot of the setup. The Ring Algorithms superimposed overlay is an undirected ring, thus we will not need to model it is a ring, even though it is a ring. We assume it to be a ring, and write the specification as if it was a ring.


\section{Setup}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} \{\@w{PROBE} ,\,\@w{SELECTED} \} \.{\times}
 ProcessID}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Initializes the variables: \ensuremath{State} and \ensuremath{MessageBox
}}%
\@xx{}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto} [}%
\@x{\@s{109.06} ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%

\@x{}\bottombar\@xx{}%

  \caption{The Setup for the Ring Algorithm}
  \label{ringsetup}
\end{figure}

The setup (See Figure \ref{ringsetup}) for the Ring Algorithm is almost identical to that of the Bully Algorithm. The only difference is how we define the \textbf{Message}s. A message in the Ring Algorithm has been changed in two ways. First, we don't send the same messages in the Ring Algorihtm. The messages in the Ring Algorithm are \textit{probe} and \textit{selected}. Second, we switch the order of message and process. In the Bully Algorithm it made sense to have the ProcessID as the first part of the message, since it is the sender of the message. In the Ring Algorithm, the process id is the ID of the message, and not the sender. Since both messages in the Ring Algorithm have an ID attached to them, the messages instead have the process on the right side. However, this is purely a syntactic choice.


\section{Neighbours and Sending Messages}

\begin{figure}

  \tlatex
\@x{}\moduleLeftDash\@xx{Neighbour}\moduleRightDash\@xx{}%
\@x{ Neighbour ( p ) \.{\defeq} ( p \.{\%} MaxAliveID ) \.{+} 1}%
\@x{}\bottombar\@xx{}%

  \caption{Neighbour function}
  \label{ringneighbour}
\end{figure}
\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{SendingMessages}\moduleRightDash\@xx{}%
\@x{ SendMessageAndTailMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,}%
\@x{\@s{126.26} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Simple \ensuremath{SendMessage}. Sends message \ensuremath{msg} to
 \ensuremath{q} with \ensuremath{id} \ensuremath{id}.
}%
\@xx{}%
\@x{ SendMessage ( q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{61.65} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ]}%
\@pvspace{8.0pt}%
\@x{ SendMessageAndEmptyMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%


\@x{}\bottombar\@xx{}%
\caption{Sending Messages}
\label{ringsendingmessages}
\end{figure}

\noindent
\textbf{Neighbour}\\
\noindent
In a ring topology, each process has a left-side neighbour and a right-side neighbour. For the Ring Algorithm we only care about the right-side neighbour. Thus, the \textit{Neighbour} function (Figure \ref{ringneighbour} returns the left-side neighbour. However, there is a flaw in this function. It assumes that only the leaders die, and no non-leaders will die. This is the only deviation from the original specification.
\\\\
\noindent
\textbf{Sending Messages}\\
\noindent
We deviate a lot from the Bully algorithm in how messages are sent. Instead of having functions for specific messages, we have two functions \textit{SendMessage} and \textit{SendMessageAndTailMessageBox}. In the Bully Algorithm, a lot had to be done when sending each message. In the Ring Algorithm, messages are only sent to neighbours, thus requiring less work choosing who to send to. In the Bully Algorithm this work was done in the sender functions, but this work is not needed in the Ring Algorithm.

The \textit{SendMessage} function updates the MessageBox of a process with a Message. The \textit{SendMessageAndTailMessageBox} is similar, except it also removes the first message in the MessageBox of $p$. This is done, because the \textit{HandleMessages} function requries both sending messages and deleting in the same state. However, in TLA$^{+}$ you cannot update a variable twice in the same state, thus requiring a function like \textit{SendMessageAndTailMessageBox} to update both message boxes at the same time. \textit{SendMessageAndEmptyMessageBox} is similar to \textit{SendMessageAndTailMessageBox}, but instead of deleting just the first message, it deletes all messages.






\section{HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{HandleMessages}\moduleRightDash\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{49.19} id \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{49.19} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{49.19} \.{\IN}}%
\@x{\@s{49.19} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
\@y{\@s{0}%
 Only if the process is active
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{43.80}}%
\@y{\@s{0}%
 The message box shouldn\mbox{'}t be empty
}%
\@xx{}%
\@x{\@s{49.19} \.{\land} \.{\lor} \.{\land} msg \.{=}\@w{PROBE}}%
\@y{\@s{0}%
 If the message is \ensuremath{PROBE
}}%
\@xx{}%
 \@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@y{\@s{0}%
 Make sure the participation status is \ensuremath{{\TRUE}
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} State [ p ] . Participating \.{=} {\TRUE}}%
\@x{\@s{93.64} \.{\land} {\UNCHANGED} State}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{=} id}, send \ensuremath{SELECTED
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, p ,\,\@w{SELECTED} )}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id\@s{4.1}}%
\@y{\@s{0}%
 If \ensuremath{p \.{>} id} ignore message
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{<} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{<} id} send probe to neighbour
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, id ,\,\@w{PROBE} )}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{SELECTED}}%
\@y{\@s{0}%
 If the message is \ensuremath{SELECTED
}}%
\@xx{}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{\neq} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{\neq} id}, then send \ensuremath{SELECTED} to neighbour
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, id ,\,\@w{SELECTED} )}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 if \ensuremath{p \.{=} id} then declare itself the leader
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%


\@x{}\bottombar\@xx{}%

  \caption{HandleMessage}
  \label{ringhandlemessages}
  \end{figure}

  \begin{calloutyellow}
    needs polish
    \end{calloutyellow}

Instead of having separate functions for handling the different messages, all of this is done in the \textit{HandleMessages} function (Figure \ref{ringhandlemessages}).

The function checks if there are any messages for process $p$, and then proceeds to check what kind of message the first message is.

In case the message received is \textit{probe}, we check first if process $p$ is participating. If it is not, we change the \textit{participating} field to be true.

Afterwards, we compare $p$ with the \textit{id} from the message.
If $p = id$, then we send the ``SELECTED'' message to the neighbour. Then the message box of $p$ is emptied. This is to ensure that no election keeps on going indefinitely.
If $p > id$, we ignore the message and just delete it. This is because we want the process with the highest ID alive to be the leader, not just the first process to send a \textit{probe}.
If $p < id$ we send the probe to the right  neighbour, and delete the message.


In case the msg is ``SELECTED'' we do not need to check whether or not the process is participating in the election, as they will have participated no matter what, as the \textit{probe} message has been all around the ring. If the $id \neq p$ then we note $id$ to be the leader and set our participation status to be \textsc{False}. We also send the \textit{selected} message to our right neighbour, so that everyone knows who the new leader is. However, if $p = id$ then $p$ is the leader, and he is noted as such by himself. There is a slight deviation from the pseudocode here. In the pseudocode it is stated that $p$ is noted by itself to be the leader, when it first sends the \textit{selected} message to its right neighbour. However, due to the limitations of TLA$^{+}$, I have decided against doing it there, as it would require a check of participation in each equality check with the \textit{id} when it receives the \textit{probe} message. This solution is simply easier to look at. The desired outcome will be the same, i.e. every process having the same leader and not being participating.


\section{Checking The Leader Condition}
\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{CheckLeader}\moduleRightDash\@xx{}%
\@x{ CheckLeader ( p ) \.{\defeq} \.{\land} State [ p ] . Condition
\.{=}\@w{Active}}%
\@x{\@s{87.92} \.{\land} State [ State [ p ] . Leader ] . Condition
\.{=}\@w{Dead}}%
\@x{\@s{87.92} \.{\land} \.{\lor} \.{\land} MaxAliveID \.{=} 1}%
\@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
Leader \.{=} p ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
\@x{\@s{110.15} \.{\land} {\UNCHANGED} MessageBox}%
\@x{\@s{99.04} \.{\lor} \.{\land} MaxAliveID \.{\neq} 1}%
\@x{\@s{110.15} \.{\land} SendMessage ( Neighbour ( p ) ,\, p ,\,\@w{PROBE}
)}%
\@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
Participating \.{=} {\TRUE} ]}%
\@xx{}%
\@x{}\bottombar\@xx{}%

  \caption{CheckLeader}
  \label{ringcheckleader}
  \end{figure}


When we check if the leader is dead in the Ring Algorithm (See Figure \ref{ringcheckleader}), we do it a bit differently than in the Bully Algorithm. Here, the only check we, other than to see if the leader is dead, do is to see if there is only one process remaining. If this is the case, we set that one process as the leader, and its participation status to be \textsc{False} ending the election (once and for all). However, if this is not the case, we send a \textit{probe} message to the right neighbour and set $p$s participation status to \textsc{True}.

\section{Next predicate and killing the leader}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Next Predicate and Kill Leader}\moduleRightDash\@xx{}%
  \@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 HandleMessages ( p ) \.{\lor} CheckLeader ( p )}%
\@x{}\bottombar\@xx{}%

\caption{Next predicate and KillLeader}
\label{ringnextleader}
\end{figure}

\begin{calloutyellow}
  too vague
  \end{calloutyellow}

KillLeader and the next predicate are identical to the Bully Algorithm.


\section{Invariants and Properties}

\chapter{Evaluation}




\chapter{Conclusion}

...While the Bully Algorithm worked fine, the Ring Algorithm did not.

\bibliography{bibliography}

\appendix

\chapter{Bully Algorithm Implementation}



\chapter{Ring Algorithm Implementation}


\end{document}

\documentclass{report}

\usepackage[a4paper]{geometry} % paper size, margins etc.

\usepackage{tlatex}
\usepackage{listings}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{lipsum}

\usepackage[most]{tcolorbox}
\usepackage{fontawesome}
\usepackage{xcolor}
\usepackage{enumitem} % Add the possibility of removing indentation in enumerate
\usepackage{multicol}

\usepackage{algorithm2e}

\definecolor{mycolor}{RGB}{242,87,87}
\definecolor{green}{RGB}{123, 224, 173}
\definecolor{yellow}{RGB}{255, 220, 94}
\definecolor{offwhite}{RGB}{248,236,224}
\newcommand*{\sans}{\fontfamily{lmss}\selectfont}

\newtcolorbox{callout}{
  enhanced,
  colback=mycolor,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutgreen}{
  enhanced,
  colback=green,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutyellow}{
  enhanced,
  colback=yellow,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}



\begin{document}
\begin{center}
       \vspace*{1cm}
       \textbf{Formal Verification of Distributed Leader Election Algorithms with Model Checking}\\
       \vspace{0.4cm}
       June 1, 2023

       \vspace{0.5cm}

       \vspace{1.5cm}

       \begin{multicols}{2}
       Student\\
       \textbf{Kevin Joshua Vinther}\\
       \textit{kevin20@student.sdu.dk}
       \vspace{0.5cm}
       \\
       Supervisor\\
       \textbf{Marco Peressotti}\\
       \textit{Peressotti@imada.sdu.dk}
       \end{multicols}


       \vfill

       \vspace{0.8cm}

\end{center}
\newpage

\tableofcontents

\chapter{Introduction}


Today, more than ever before, distributed systems are crucial in computer infrastructure. However, they are also notoriously difficult to implement correctly. Even only a few interacting processes in a distributed system can lead to a tremendous amount of states. Catching each bug and edge case in the many possible states can take an enormous amount of time, and be exceedingly challenging.

Leader election is a distributed algorithm which requires that all processes in a distributed system agree on one specific process as their leader. This is crucial for many modern systems as distributed algorithms are typically not completely symmetrical, and therefore some process has to take the lead in initiating the algorithm, which a leader election algorithm can do. Leader election is also used because it saves resources by making sure that no process other than the leader replicates the algorithm initiation.

It is a challenge to verify that distributed algorithms work as intended in a distributed system using conventional tools today. Therefore, we use techniques from formal verification methods, because they help us test distributed algorithms in a way that no conventional tool can.

We seek to verify the correctness of two distributed leader election algorithms: the Bully Algorithm and the Ring Algorithm\footnote{The Ring Algorithm is a familiar name for the Lelang, Chang and Roberts algorithm (also known as LCR). We will continue to use the name ``Ring Algorithm''.}.

We do this using techniques from formal methods to check if there are any bugs, concurrency issues and security issues in the algorithm. Throughout this project the TLA$^{+}$ (Temporal Logic of Actions Plus) verification suite is used to model the Ring and Bully Algorithm

In the TLA$^{+}$ verification suite, the TLC model is included. The model checker verifies the algorithm by going through each possible state, and making sure that it produces satisfiable behavior, thus verifying if an algorithm works even in the cases that are close to impossible using conventional tools.

Thus, the goal of this project is to have modelled both the Bully Algorithm and the Ring Algorithm in the TLA$^{+}$ specification language, and have tested them using the TLC model checker.

\chapter{Overview}

\section{Leader Election}

In several algorithms for distributed systems, a process may posses the role of the \textit{leader}. Usually a leader may be required because distributed algorithms typically are not completely symmetrical. Thus, the leader can take the lead in initiating the algorithm. This also saves resources in the system, as it ensures that only the leader will take the initiative in an algorithm, and that other processes won't do it as well.

The aim of an algorithm for the Leader Election problem is to elect a leader from a set of processes in a way that all processes can agree on the same leader. It is crucial that all processes agree on the same leader, as if one process has the wrong leader, it can lead to many failures in the system.

%This \textit{report?} will search to implement two leader election algorithms: The \textit{Bully Algorithm} and the \textit{Ring Algorithm}\footnote{Also known as the Lelang, Chang and Roberts (LCR) algorithm, but commonly referred to as the Ring algorithm, as will be done in this \texit{report?}}
%This should probably be discussed in the introduction.

This project focuses on the Bully Algorithm and the Ring Algorithm. The Ring Algorithm works on a complete graph, with an undirected ring superimposed. The Bully Algorithm works on a complete undirected graph.

For both the Bully and Ring Algorithm we assume that:
\begin{itemize}
  \item The network is reliable. Messages do not get lost.
  \item Nodes may fail at any time, including the leader.
  \item Fail-stop model. Failed nodes are removed from the system forever.
  \item Messages are asynchronous.
\end{itemize}


\section{Bully Algorithm}

In the Bully Algorithm, the elected leader will either be the leader with the lowest ID, or the highest ID. In this project, we assume that the leader is the process with the highest id.

In the algorithm, there exists three different types of message to be sent and received. These messages initiate behavior on the receiving process, depending on what the contents of the message is. The messages are:
\begin{itemize}
  \item \textit{election}: sent to announce an election.
  \item \textit{alive}: sent to respond to an \textit{election} message from a lower id.
  \item \textit{victory}: sent by winner to announce victory.
\end{itemize}

Rather than traditional pseudocode, we base ourself on a series of instructions (which throughout the report will be referred to as pseudocode.)

When a process $p$ recovers from failure, or the failure detector indicates that the current leader has failed, $p$ performs the following actions:

\begin{enumerate}
\item If $p$ has the highest process \textit{id}, it sends a \textit{victory} message to all other processes and becomes the new leader. Otherwise, $p$ broadcasts an \textit{election} message to all other processes with higher process \textit{id}s than itself.
\item If $p$ receives no \textit{alive} after sending an \textit{election} message, then it broadcasts a \textit{victory} message to all other processes and becomes the leader.
\item If $p$ receives an \textit{alive} from a process with a higher \textit{id}, it sends no further messages for this election and waits for a \textit{victory} message. (If there is no \textit{victory} message after a period of time, it restarts the process at the beginning.)
\item If $p$ receives an \textit{election} message from another process with a lower \textit{id} it sends an \textit{alive} message back and if it has not already started an election, it starts the election process at the beginning, by sending an \textit{election} message to higher-numbered processes.
\item If $p$ receives a \textit{victory} message, it treats the sender as the leader.
\end{enumerate}

\section{Ring Algorithm}

The Ring Algorithm, like the Bully Algorithm, solves the problem of leader election. However, unlike the Bully Algorithm, the Ring Algorithm assumes a superimposed undirected ring. This means that we assume the processes to be in a ring, and model the implementation from this assumption.

In the Ring Algorithm, there exists two different types of messages:
\begin{itemize}
  \item \textit{probe(id)}: sent to search for the leader.
  \item \textit{selected(id)}: sent to announce the result.
\end{itemize}

You will notice in the messages, that, unlike in the Bully Algorithm, they have an attached \textit{id}. While it may read as if it is a function, it is just an attachment to the message. The \textit{id} is used to identify who originally sent the message.

Furthermore, the Ring Algorithm requires a \textit{boolean} variable, called \textit{participate}. The variable indicates whether or not process $P_{i}$ participates in the election.

Like in the Bully Algorithm, we base ourself on a set of instructions rather than traditional pseudocode.

\noindent
When process $P_{i}$ wakes up to participate in the election:
\begin{enumerate}
  \item Send \textit{probe(i)} to right neighbour
        \item \textit{participate }$\leftarrow $ \textsc{True}
\end{enumerate}

\noindent
When \textit{probe(k)} message arrives from the left neighbour $P_{j}$:
\begin{enumerate}
  \item If \textit{participate} = \textsc{False} then \textit{participate} $\leftarrow$ \textsc{True}.
  \item if $i > k$ then discard the probe
  \item else if $i < k$ then forward \textit{probe(k)} to right neighbor
  \item else if $i = k$ then declare $i$ is the leader; circulate \textit{selected(i)} to right neighbour;
\end{enumerate}

\noindent
When a \textit{selected(x)} message arrives from left neighbour:
\begin{enumerate}
  \item if $x \neq i$ then note $x$ as the leader and forward message to right neighbor
        \item else do not forward the \textit{selected} message.
\end{enumerate}

In this algorithm, like in the Bully Algorithm, we assume that the leader will be the process with the highest id alive.

\chapter{Bully Algorithm}

\section{Converting to TLA+}
Since we have based ourself on an instruction set rather than pseudocode for what process $p$ should do, it has been more a process of modelling the algorithm correctly, rather than converting it from pseudocode.

The second point in the algorithm described earlier states that, if process $p$ receives no \textit{alive} message after sending an Election message, it then broadcasts an \textit{victory} message to all other processes. Since TLA$^{+}$ does not allow for waiting a specified amount of time, and we assume a \textit{fail-stop} model, instead of waiting to see, it immediately checks if process P is the process with the highest ID alive, and broadcasts a \textit{victory} message if this is the case. We allow ourself this because the \textit{fail-stop} assumes that all processes will know the failure of other processes, but it is not specified how. Therefore, we can assume that the process will know that it is the highest process. This is also done in the beginning of the algorithm, when a process checks if a leader is dead. However, the rest of the implementation is as true to the set of instructions as possible.

Furthermore, I have made a modification to point 4. However, as this is not done because of limitations of TLA$^{+}$, it is discussed in Section \ref{bullyreceivemessagessection}.
\section{Setup}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@pvspace{8.0pt}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} ProcessID \.{\times} \{\@w{ELECTION} ,\,\@w{ALIVE}
 ,\,\@w{VICTORY} \}}%
\@pvspace{8.0pt}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto}}%
\@x{\@s{109.06} [ ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\fl{}\bottombar\cl{}

\caption{Setup for the Bully Algorithm}
\label{bullysetup}
\end{figure}

Before modeling the behavior of the specification, we set up the constants, variables and initialize them in the \textit{Init} function. Looking at the specification for the algorithm, we need to model processes and messages.

The algorithm assumes a complete undirected graph. We model this by creating a \textbf{State} variable, which contains a record of all \textit{processes} and their fields. We define the \textbf{State} variable to be a sequence of records, each of which hold the following metadata in its fields (Figure \ref{bullysetup}):
\begin{itemize}
    \item \textit{ID}: The process has a unique ID. $ID \in ProcessID$, where $ProcessID$ is the total number of processes, defined as a range from 1 to the natural number N.
    \item \textit{Condition}: A process is either dead or alive (called \textit{active}). Due to the assumptions of the algorithm we assume that each process knows when another process is dead. Condition $\in$ \{{\sans"Dead", "Active"}\}
    \item \textit{Leader}: The process should know who its leader is. The leader may be the process itself. $Leader \in ProcessID$
    \item \textit{Participating}: The process is either participating in the election or not. $Participating \in$ {\small \textsc{Boolean}}
\end{itemize}
Furthermore, we define a sequence, \textbf{MessageBox} which holds every processes received messages. The MessageBox maps from each process, $p$ initially to an empty tuple, and when messages are received, a sequence of messages. These tuples are the \textbf{Message}s. We define a \textbf{Message} as ProcessID $\times$ \{{\sans ``ELECTION'', ``ALIVE'', ``VICTORY''}\}, thus an example of an {\sans ``ELECTION''} message from process $1$ is: $\langle1,$ {\sans ``ELECTION''} $\rangle$.

\section{Sending Messages}


\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Sending Messages}\moduleRightDash\@xx{}%

\@x{ SendAliveAndTail ( p ,\, q ) \.{\defeq}}%
 \@x{\@s{16.4} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q
 ]\@s{0.25} \.{=} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{ALIVE}
 {\rangle} ) ,\,}%
\@x{\@s{185.43} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{ SendVictory ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{49.19} {\IF} q \.{\neq} p \.{\land} State [ q ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{49.19} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{VICTORY} {\rangle} )}%
\@x{\@s{49.19} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendVictoryAndTail ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
\@x{\@s{32.8} {\IF} State [ q ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} {\IF} q \.{=} p \.{\THEN} Tail ( MessageBox [ q ] )
 \.{\ELSE} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{VICTORY}
 {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendElection ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{32.8} {\IF} q \.{\in} HigherIDs ( p ) \.{\land} State [ q ] .
 Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{ELECTION} {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%


\fl{}\bottombar\cl{}

\caption{The \textit{sender} functions}
\label{bullysendingmessages}
\end{figure}

We earlier defined the \textbf{MessageBox} to be a sequence of \textbf{Message}s. This makes the handling of messages extremely convenient. One of the core operations we make with messages are sending them. To send a message from process $p$ to process $q$ with the contents {\sans ELECTION}, we simply append the tuple $\langle p, $ {\sans ``ELECTION''} $\rangle$ to \textit{MessageBox[q]}. In TLA$^{+}$ this is done like so:
\begin{lstlisting}
MessageBox'
     = [MessageBox EXCEPT ![q] = Append(<<p, ''ELECTION''>>)]
\end{lstlisting}
This defines the MessageBox variable to have $\langle p, $ {\sans ``ELECTION''} $\rangle$ appended to \textit{MessageBox[q]} in the next state.

In the sender functions (Figure \ref{bullysendingmessages}) you will notice two different types of sending predicates: one which is simply ``SendX'', and one which is ``SendXAndTail''. The AndTail variant does the same as SendX, except it also removes the newest message in process $p$'s inbox. This is done as to not clutter the inbox with irrelevant messages.

As discussed earlier, there are three different messages in the bully algorithm: \textit{alive}, \textit{victory}, and \textit{election}.

The \textit{alive} message is only sent in a case where a process receives an \textit{election} message from a process with a lower id. Thus, no additional work is needed other than process $q$ should receive an \textit{alive} message from process $p$. This job is done by the \textit{SendAliveAndTail} function. Since it as an ``AndTail'' function it also removes the newest message by setting the message box of $p$ to be the tail of the message box.

The \textit{SendVictory} function is similar, only it sends the \textit{victory} message to all processes except the sender. We assume a fail-stop model, meaning that the other processes learn when a process dies, allowing us to send only to the alive processes. This function also has a ``AndTail'' variant, which is identical except it tails $p$'s message box.

\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{MaxAliveID}\moduleRightDash\@xx{}%
\@xx{}%
\@x{ MaxAliveID \.{\defeq} {\CHOOSE} id \.{\in} ProcessID \.{:}}%
 \@x{\@s{80.15} \A\, p \.{\in} ProcessID \.{:} State [ p ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{163.18} \.{\lor} id \.{\geq} State [ p ] . ID}%
\fl{}\bottombar\cl{}

  \caption{Function that returns the highest ID alive}
  \end{figure}

\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{HigherIDs}\moduleRightDash\@xx{}%
 \@x{ HigherIDs ( p ) \.{\defeq} \{ q \.{\in} 1 \.{\dotdot} MaxAliveID \.{:} q
 \.{>} p \}}%
\fl{}\bottombar\cl{}
\label{higherids}
  \caption{Function which returns all IDs higher than $p$}
\end{figure}

Similar to the \textit{victory} message, the \textit{election} message is sent to a select group of processes. This time it's all processes with a higher ID than $p$. This is achieved using a helper function \textit{HigherIDs} (see figure \ref{higherids}.)

\section{Handling Received Messages} \label{bullyreceivemessagessection}


\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Handle Received Messages}\moduleRightDash\@xx{}%

 \@x{ ReceiveAlive ( p ,\, q ) \.{\defeq} \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
\@y{\@s{0}%
 Make sure they are already participating
}%
\@xx{}%
\@x{\@s{98.58} \.{\land} p \.{>} q}%
 \@x{\@s{98.58} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ]}%
\@y{\@s{0}%
 No longer participate
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ReceiveElection ( p ,\, q ) \.{\defeq}\@s{4.1} \.{\lor} \.{\land} p
 \.{=} MaxAliveID}%
\@x{\@s{126.95} \.{\land} SendVictoryAndTail ( p )}%
 \@x{\@s{126.95} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\,}%
\@x{\@s{244.46} {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{115.84} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
 \@x{\@s{126.95} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating
 \.{=} {\TRUE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
\@x{\@s{149.18} \.{\land} {\UNCHANGED} State}%
 \@x{\@s{138.07} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
 \@x{\@s{149.18} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
 \@x{ ReceiveVictory ( p ,\, q ) \.{\defeq} State \.{'} \.{=} [ State
 {\EXCEPT} {\bang} [ p ] . Leader \.{=} q ]}%
\@y{\@s{0}%
 Set the leader of receiver to \ensuremath{p} sender
}%
\@xx{}%

\fl{}\bottombar\cl{}

\caption{Message Handlers}
\label{messagehandlers}
\end{figure}

When a message is received, a process will periodically use the \textit{HandleMessages} function. This will then execute the correct functions depending on the message. The functions in Figure \ref{messagehandlers} describe the behavior when receiving a specific message.

Points 3, 4, and 5 from the pseudocode describe what to do when receiving messages:

\begin{enumerate}
  \setcounter{enumi}{2}
  \item If P receives an alive from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)
  \item If P receives an Election message from another process with a lower ID it sends an alive message back and if it has not already started an election, it starts the election process at the beginning, by sending an Election message to higher-numbered processes.
  \item If P receives a victory message, it treats the sender as the leader.
\end{enumerate}

The function \textit{ReceiveAlive} addresses point 3. It checks if the message is from a higher id than itself, and if so, it modifies its participation status to be \textsc{False}.

The function \textit{ReceiveElection} addresses point 4. However, you may notice that it does not correctly follow point 4. Point 4 explicitly states that \textbf{``...if it has not already started an election, it starts the elction process at the beginning, by sending an Election message to higher-numbered processes''}. Instead of doing this, it only sends an alive message, and, if its own participation status is \textsc{False}, it sets it to be \textsc{True} instead. This change is done because it will only lead to a number of irrelevant \textit{election} messages. Furthermore, we have deviated from point 4 in the sense that we check if the process has the highest ID alive, and if so, it declares victory. This is done because we assume a fail-stop model.

The \textit{ReceiveVictory} function (Figure \ref{messagehandlers}) addresses point 5 by setting the leader to the sender of the \textit{victory} message.


\section{Delegating Functions with HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Delegate Messages}\moduleRightDash\@xx{}%
\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{93.62} sender \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{93.62} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{93.62} \.{\IN}}%
\@x{\@s{97.72} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{97.72} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{4.1}}%
\@y{\@s{0}%
 Message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{97.72} \.{\land} \.{\lor} \.{\land} State [ sender ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%
\@x{\@s{119.95} \.{\land} {\UNCHANGED} State}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{VICTORY}}%
\@y{\@s{0}%
 If the message is \ensuremath{VICTORY
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveVictory ( p ,\, sender )}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@y{\@s{0}%
 Remove all messages
}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ELECTION}}%
\@y{\@s{0}%
 If the message is \ensuremath{ELECTION
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveElection ( p ,\, sender )}%
\@y{\@s{0}%
 Tail is done incide \ensuremath{ReceiveElection
}}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ALIVE}}%
\@y{\@s{0}%
 If the message is \ensuremath{ALIVE
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveAlive ( p ,\, sender )}%
\@y{\@s{0}%
 Handle in \ensuremath{ReceiveAlive
}}%
\@xx{}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%

\fl{}\bottombar\cl{}

\caption{Delegating Functions}
\label{handlemessages}
\end{figure}

In the \textit{Next} predicate of the specification, one of the actions a process can take is to check its messages. This is done via the \textit{HandleMessages} function. If process $p$ has any messages in their inbox, one of 4 things can happen, depending on the type of message or the condition of the sender.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]
  \item If the sender is dead, we ignore the message and delete it from the inbox of process $p$.
  \item If the content of the message is \textit{victory}, we delegate work to the \textit{ReceiveVictory} function and remove all messages from process $p$ because we do not care about other message at this point.
  \item If the content of the message is \textit{election}, we delegate the rest of the work to the \textit{ReceiveElection} function.
  \item If the content of the message is \textit{alive}, we delegate work to the \textit{ReceiveAlive} function and delete the message from the inbox of process $p$.
\end{enumerate}

\section{Checking the leader condition}

\begin{figure}
\tlatex

\@xx{}%
 \@x{ CheckLeader ( p ) \.{\defeq}\@s{8.2} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{96.12} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{96.12} \.{\land} \.{\lor} \.{\land} p \.{=} MaxAliveID}%
\@x{\@s{118.35} \.{\land} SendVictory ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\, {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{107.24} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
\@x{\@s{118.35} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
\@x{\@s{118.35} \.{\land} SendElection ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%


\fl{}\bottombar\cl{}

\caption{Checking the condition of the leader}
\label{checkleader}
\end{figure}

One of the actions a process can take in the \textit{next} state relation is to check the condition of the leader.
In the pseudocode, it is specified that ``When a process P recovers from failure, or the failure detector indicates that the current leader has failed...''. Since we assume that the processes do not recover from failure we use the \textit{CheckLeader} (Figure \ref{checkleader}) function instead.

The function only runs if the process checking is active, and the leader is dead. If the process is active, the function checks whether process $p$ is the process with the highest id. If $p$ has the highest id, it sends a \textit{victory} message, and declares itself the new leader. If $p$ is not the process with the highest id, we first make sure that it is not currently participating in any election, as to not accidentally start multiple elections in one cycle. Then process $p$ sends an election message, and sets its own Participation status to \textsc{True}, as it is now in an election.


\section{Next state relation and killing the leader}
\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{NextPredicateAndKillLeader}\moduleRightDash\@xx{}%

\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ,\, {\bang} [ MaxAliveID ] .
 Participating \.{=} {\FALSE} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 CheckLeader ( p ) \.{\lor} HandleMessages ( p )}%

\fl{}\bottombar\cl{}
\caption{Next state relation and KillLeader}
\label{nextpredkillleader}
\end{figure}

The Next state relation (Figure \ref{nextpredkillleader}) chooses what should happen in the next state.
For this specification there are two options: Either, the leader is killed, or a process handles its messages or checks its leaders status.

In case the choice is made to kill the leader, we make sure that the leader sees itself as the leader, and if they do, we change its condition in the next state relation to be dead and its participation status to be \textsc{False}, effectively killing it. This is only done if there are 2 or more processes alive.

In case the decision to kill the leader is not chosen, a process is chosen to either check its leader or handle its messages.


\section{Invariants and properties}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Invariants and Properties}\moduleRightDash\@xx{}%
\@x{}%
\@y{\@s{0}%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Each variable should be within the type constraints
}%
\@xx{}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Every process should have a unique \ensuremath{ID
}}%
\@xx{}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If a process is participating in the election, then it should not be the
 leader
}%
\@xx{}%
 \@x{ Participating \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{=} {\TRUE} \.{\implies} State [ p ] . Leader \.{\neq} p}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{\@s{0}%
 Properties
}%
\@xx{}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{16.0pt}%
\@x{}%
\@y{\@s{0}%
 The highest alive process should become the leader
}%
\@xx{}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{16.4} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} ( {\Diamond} ( State [ p ] . Participating \.{=}
 {\FALSE} ) )}%
\@pvspace{16.0pt}%
\@x{}\bottombar\@xx{}%

  \caption{Invariants and Properties in the Bully Algorithm}
  \label{bullyinvariantsproperties}
  \end{figure}

\textbf{Invariants}\\
\noindent
In TLA$^{+}$, an \textit{invariant} is a statement that must be true on every state of the program. One common type of invariant is the \textit{TypeOK} invariant (Figure \ref{bullyinvariantsproperties}). \textit{TypeOK} makes sure that the types never go out of a specified domain or change to an unwanted value. In the case of this specification this is true for the \textit{State} and \textit{MessageBox} variables. For the \textit{State} variable, it will hold true that:
\begin{itemize}
  \item A process' \textit{id} is a part of the \textit{ProcessID}
  \item A process' condition is either \textit{Active} or \textit{Dead}
  \item A process' \textit{leader} is a part of the \textit{ProcessID} set
  \item A process' participation status is a \textsc{Boolean}
\end{itemize}
For the message box it holds that each ID will map to a sequence of messages.

In this specification, we also have an invariant called \textit{UniqueID} which makes sure that no two processes hold the same ID. Furthermore, we also have an invariant called \textit{Participating} which states that, if a process is participating in an election, it cannot be the leader itself, or see itself as leader.

\\\\
\noindent
\textbf{Properties}\\
\noindent
There are two kinds of temporal properties: safety properties, and liveness properties. Safety properties make sure that the system doesn't do bad things, and liveness makes sure our system always does a good thing.

We have three properties: two safety properties and one liveness property. The safety properties are \textit{ElectionTerminationImpliesSameLeader}, and \textit{HighestAliveProcessIsLeader}. \textit{ElectionTerminationImpliesSameLeader} ensures that when two processes that have been in an election eventually get out of the election, they will have the same leader. \textit{HighestAliveProcessIsLeader} ensures that if a process is not participating in an election, its leader is the process with the highest id alive.

The liveness property, \textit{ElectionWillEnd} ensures that an election will eventually end.

\section{Temporal Formula}

\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Temporal Formula}\moduleRightDash\@xx{}%

 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%

\@x{}\bottombar\@xx{}%

\caption{Temporal Formula}
\label{bullyspec}
\end{figure}


To run the specification with the model checker, the temporal formula in Figure \ref{bullyspec} is used. The reason a temporal formula is used rather than just specifying the Initial predicate and Next-state relation is to use \textit{strong fairness}. Without strong fairness, the model checker might just decide to stop the entire system. That is an intended feature, but it is not what we want. Strong fairness says that if an action is always enabled, it eventually happens.


\chapter{Ring Algorithm}


\section{Similarities to Bully Algorithm}
The Ring Algorithm and the Bully Algorithm are both similar in many ways. One similarity which carries over from our implementation of the Bully Algorithm to the Ring Algorithm is the modeling of the graphs. Since the Ring Algorithm is also an algorithm on graphs, we can reuse a lot of the setup. Furthermore, the Ring Algorithms superimposed overlay is an undirected ring. We will not need to model it is a ring, even though it is a ring. Instead, we assume it to be a ring, and write the specification as if it was a ring.


\section{Setup}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} \{\@w{PROBE} ,\,\@w{SELECTED} \} \.{\times}
 ProcessID}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Initializes the variables: \ensuremath{State} and \ensuremath{MessageBox
}}%
\@xx{}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto} [}%
\@x{\@s{109.06} ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%

\@x{}\bottombar\@xx{}%

  \caption{The Setup for the Ring Algorithm}
  \label{ringsetup}
\end{figure}

The setup (See Figure \ref{ringsetup}) for the Ring Algorithm is almost identical to that of the Bully Algorithm. The only difference is how we define the \textbf{Message}s. A message in the Ring Algorithm has been changed in two ways. First, we don't send the same messages in the Ring Algorihtm. The messages in the Ring Algorithm are \textit{probe} and \textit{selected}. Second, we switch the order of message and process. In the Bully Algorithm it made sense to have the ProcessID as the first part of the message, since it is the sender of the message. In the Ring Algorithm, the process id is the ID of the message, and not the sender. Since both messages in the Ring Algorithm have an ID attached to them, the messages instead have the process on the right side. However, this is purely a syntactic choice.


\section{Neighbours and Sending Messages}

\begin{figure}

  \tlatex
\@x{}\moduleLeftDash\@xx{Neighbour}\moduleRightDash\@xx{}%
\@x{ Neighbour ( p ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} AliveProcesses \.{\defeq} \{ q \.{\in} ProcessID \.{:}
 State [ q ] . Condition \.{=}\@w{Active} \}}%
\@x{\@s{16.4} \.{\IN}}%
 \@x{\@s{16.4} {\IF} p \.{=} MaxAliveID \.{\THEN} {\CHOOSE} q \.{\in}
 AliveProcesses \.{:} {\TRUE} \.{\ELSE}}%
\@x{\@s{51.73} {\CHOOSE} neighbour \.{\in} AliveProcesses \.{:}}%
\@x{\@s{94.51} \.{\land} p \.{<} neighbour}%
 \@x{\@s{94.51} \.{\land} \A\, q \.{\in} AliveProcesses \.{:} q \.{\leq} p
 \.{\lor} neighbour \.{\leq} q}%


\@x{}\bottombar\@xx{}%

  \caption{Neighbour function}
  \label{ringneighbour}
\end{figure}
\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{SendingMessages}\moduleRightDash\@xx{}%
\@x{ SendMessageAndTailMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,}%
\@x{\@s{126.26} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Simple \ensuremath{SendMessage}. Sends message \ensuremath{msg} to
 \ensuremath{q} with \ensuremath{id} \ensuremath{id}.
}%
\@xx{}%
\@x{ SendMessage ( q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{61.65} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ]}%
\@pvspace{8.0pt}%
\@x{ SendMessageAndEmptyMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%


\@x{}\bottombar\@xx{}%
\caption{Sending Messages}
\label{ringsendingmessages}
\end{figure}

\noindent
\textbf{Neighbour}\\
\noindent
In a ring topology, each process has a left-side neighbour and a right-side neighbour. For the Ring Algorithm we only care about the right-side neighbour. Thus, the \textit{Neighbour} function (Figure \ref{ringneighbour} returns the left-side neighbour. However, there is a flaw in this function, that makes it deviate from the original pseudocode. It assumes that only the leaders die, and no non-leaders will die. This is the only deviation from the original specification.
\\\\
\noindent
\textbf{Sending Messages}\\
\noindent
We deviate a lot from the Bully algorithm in how messages are sent. Instead of having functions for specific messages, we have two functions \textit{SendMessage} and \textit{SendMessageAndTailMessageBox}. In the Bully Algorithm, a lot had to be done when sending each message. In the Ring Algorithm, messages are only sent to neighbours, thus requiring less work choosing who to send to. In the Bully Algorithm this work was done in the sender functions, but this work is not needed in the Ring Algorithm.

The \textit{SendMessage} function updates the MessageBox of a process with a Message. The \textit{SendMessageAndTailMessageBox} is similar, except it also removes the first message in the MessageBox of $p$. This is done, because the \textit{HandleMessages} function requries both sending messages and deleting in the same state. However, in TLA$^{+}$ you cannot update a variable twice in the same state, thus requiring a function like \textit{SendMessageAndTailMessageBox} to update both message boxes at the same time. \textit{SendMessageAndEmptyMessageBox} is similar to \textit{SendMessageAndTailMessageBox}, but instead of deleting just the first message, it deletes all messages.






\section{HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{HandleMessages}\moduleRightDash\@xx{}%

\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{49.19} id \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{49.19} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{49.19} \.{\IN}}%
\@x{\@s{49.19} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
\@y{\@s{0}%
 Only if the process is active
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{43.80}}%
\@y{\@s{0}%
 The message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} \.{\lor} \.{\land} State [ id ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{71.42} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{71.42} \.{\land} {\UNCHANGED} State}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{PROBE}}%
\@y{\@s{0}%
 If the message is \ensuremath{PROBE
}}%
\@xx{}%
 \@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@y{\@s{0}%
 Make sure the participation status is \ensuremath{{\TRUE}
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} State [ p ] . Participating \.{=} {\TRUE}}%
\@x{\@s{93.64} \.{\land} {\UNCHANGED} State}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{=} id}, send \ensuremath{SELECTED
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, p ,\,\@w{SELECTED} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id\@s{4.1} \.{\land} State [ p ] .
 Participating \.{=} {\FALSE}}%
\@y{\@s{0}%
 If \ensuremath{p \.{>} id} ignore message
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, p ,\,\@w{PROBE} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{<} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{<} id} send probe to neighbour
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, id ,\,\@w{PROBE} )}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{SELECTED}}%
\@y{\@s{0}%
 If the message is \ensuremath{SELECTED
}}%
\@xx{}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{\neq} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{\neq} id}, then send \ensuremath{SELECTED} to neighbour
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, id ,\,\@w{SELECTED} )}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 if \ensuremath{p \.{=} id} then declare itself the leader
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%

\@x{}\bottombar\@xx{}%

  \caption{HandleMessages}
  \label{ringhandlemessages}
  \end{figure}

Instead of having separate functions for handling the different messages, all of this is done in the \textit{HandleMessages} function (Figure \ref{ringhandlemessages}).

The function checks if there are any messages for process $p$, and then proceeds to check what kind of message the first message is.
\\\\
\noindent
\textbf{Receiving a \textit{probe} message}\\
\noindent
In case the message received is \textit{probe}, we check first if process $p$ is participating. If it is not, we change the \textit{participating} field to be true.

Afterwards, we compare $p$ with the \textit{id} from the message.
If $p = id$, then the probe has circled around all processes, and we send the ``SELECTED'' message to the neighbour. The message box of $p$ is then emptied. We empty the message box to ensure that there aren't any excess messages that will harm the election.\\
If $p > id$, we deviate from the original pseudocode. The original pseudocode states that: ``if p > id, discard the probe.'' However, this leads to cases with infinite loops of \textit{probe} messages. Thus, instead what we do is, if $p > id$ and $p$ is not participating in the election, we send a new \textit{probe} message with $p$ as the id, so that it can become the leader. If $p$ however is participating, we just discard the message.\\
If $p < id$ we send the probe to the right  neighbour, and delete the message.
\\\\
\noindent
\textbf{Receiving a \textit{selected} message}\\
\noindent
In case the msg is ``SELECTED'' we do not need to check whether or not the process is participating in the election, as they will have participated no matter what, as the \textit{probe} message has been all around the ring. If the $id \neq p$ then we note $id$ to be the leader and set our participation status to be \textsc{False}. We also send the \textit{selected} message to our right neighbour, so that everyone knows who the new leader is. However, if $p = id$ then $p$ is the leader, and he is noted as such by himself. There is a slight deviation from the pseudocode here. In the pseudocode it is stated that $p$ is noted by itself to be the leader, when it first sends the \textit{selected} message to its right neighbour. However, due to the limitations of TLA$^{+}$, I have decided against doing it there, as it would require a check of participation in each equality check with the \textit{id} when it receives the \textit{probe} message. This solution is simply easier to look at. The desired outcome will be the same, i.e. every process having the same leader and not being participating.


\section{Checking The Leader Condition}
\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{CheckLeader}\moduleRightDash\@xx{}%
\@x{ CheckLeader ( p ) \.{\defeq} \.{\land} State [ p ] . Condition
\.{=}\@w{Active}}%
\@x{\@s{87.92} \.{\land} State [ State [ p ] . Leader ] . Condition
\.{=}\@w{Dead}}%
\@x{\@s{87.92} \.{\land} \.{\lor} \.{\land} MaxAliveID \.{=} 1}%
\@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
Leader \.{=} p ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
\@x{\@s{110.15} \.{\land} {\UNCHANGED} MessageBox}%
\@x{\@s{99.04} \.{\lor} \.{\land} MaxAliveID \.{\neq} 1}%
\@x{\@s{110.15} \.{\land} SendMessage ( Neighbour ( p ) ,\, p ,\,\@w{PROBE}
)}%
\@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
Participating \.{=} {\TRUE} ]}%
\@xx{}%
\@x{}\bottombar\@xx{}%

  \caption{CheckLeader}
  \label{ringcheckleader}
  \end{figure}


When we check if the leader is dead in the Ring Algorithm (See Figure \ref{ringcheckleader}), we do it a bit differently than in the Bully Algorithm. Here, the only check we, other than to see if the leader is dead, do is to see if there is only one process remaining. If this is the case, we set that one process as the leader, and its participation status to be \textsc{False} ending the election (once and for all). However, if this is not the case, we send a \textit{probe} message to the right neighbour and set $p$s participation status to \textsc{True}.

\section{Next state relation and killing the leader}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Next state relation and Kill Leader}\moduleRightDash\@xx{}%
  \@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 HandleMessages ( p ) \.{\lor} CheckLeader ( p )}%
\@x{}\bottombar\@xx{}%

\caption{Next state relation and KillLeader}
\label{ringnextleader}
\end{figure}

KillLeader and the next state relation are identical to the Bully Algorithm.

\section{Invariants and Properties}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Invariants and Properties}\moduleRightDash\@xx{}%

\@y{%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{%
 Properties
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} ( {\Diamond} ( State [ p ] . Participating \.{=}
 {\FALSE} ) )}%
\@pvspace{8.0pt}%


\@x{}\bottombar\@xx{}%
  \caption{Invariants and Properties}
  \label{ringinvariants}
  \end{figure}

The Ring Algorithm does not introduce any new invariants or properties (Figure \ref{ringinvariants}) that the Bully Algorithm does not already have. However, the invariant \textit{Participating} (Figure \ref{bullyinvariantsproperties}) is not present. The Participating invariant does not work in the Ring Algorithm, since it checks whether or not a leader is participating, however, a leader will participate in the election if it receives a \textit{probe} message.
However, all of the other invariants and properties are identical to those of the Bully Algorithm.

\section{Temporal Formula}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Temporal Formula}\moduleRightDash\@xx{}%
 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%
\@x{}\bottombar\@xx{}%
  \caption{Temporal Formula}
  \label{ringtemporalformula}
  \end{figure}

  Like in the Bully Algorithm, the Ring Algorithm also uses a temporal formula rather than stating the initial predicate and the next-state relation in the model checker. Like in the Bully Algorithm, this is done to use \textit{strong fairness}.

\chapter{Evaluation}
\section{The Model Checker}
Both the Ring Algorithm and the Bully Algorithm have been thoroughly checked with the TLC Model Checker, which comes with the TLA$^{+}$ toolbox. The Ring Algorithm has been checked with $n = 1..10$, where $n$ is the number of processes. The Bully Algorithm has been checked with $n = 1..5$. Both algorithms pass the checker without any errors, invariant violations or temporal property violations.

You can see the state space progress, with the diameter, number of states found and distinct states for the Ring Algorithm in Table \ref{numstatesmodelcheckerringalgorithm} and for the Bully Algorithm in Table \ref{numstatesmodelcheckerbullyalgorithm}.
\\\\
\noindent
\textbf{Ring Algorithm}\\
\noindent
\begin{calloutyellow}
  Should the $r^{2}$ be said? I'm really unsure about this part in general
  \end{calloutyellow}
As you can see in table \ref{numstatesmodelcheckerringalgorithm}, the number of states found increase exponentially ($r^{2} = 0.9964$).

\noindent
\textbf{Bully Algorithm}\\
\noindent



\begin{table}[]
  \centering
\begin{tabular}{|l|l|l|l|l|}
\hline
$n$ & Diameter & States Found & Distinct States & Queue Size \\ \hline
1   & 1        & 1            & 1               & 0          \\ \hline
2   & 3        & 3            & 3               & 0          \\ \hline
3   & 9        & 17           & 13              & 0          \\ \hline
4   & 19       & 66           & 38              & 0          \\ \hline
5   & 27       & 232          & 101             & 0          \\ \hline
6   & 40       & 773          & 262             & 0          \\ \hline
7   & 53       & 2478         & 676             & 0          \\ \hline
8   & 69       & 7710         & 1760            & 0          \\ \hline
9   & 87       & 23434        & 4584            & 0          \\ \hline
10  & 107      & 69923        & 11967           & 0          \\ \hline
\end{tabular}
  \caption{Number of states found with the model checker in the Ring Algorithm}
  \label{numstatesmodelcheckerringalgorithm}
\end{table}
\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
$n$ & Diameter & States Found & Distinct States & Queue Size \\ \hline
1   & 1        & 1            & 1               & 0          \\ \hline
2   & 3        & 3            & 3               & 0          \\ \hline
3   & 7        & 50           & 28              & 0          \\ \hline
4   & 14       & 7235         & 2628            & 0          \\ \hline
5   & 29       & 7315267      & 2090268         & 0          \\ \hline
\end{tabular}
  \caption{Number of states found with the model checker in the Bully Algorithm}
  \label{numstatesmodelcheckerbullyalgorithm}
\end{table}


\section{Shortcomings}
The biggest shortcoming, which has an actual effect on the algorithm is the Neighbour function (Figure \ref{ringneighbour}), which does not accurately model a neighbour in a ring structure, as it assumes that only the leader can die. I decided against modeling the function in a more realistic way, as to focus on attempting to find out why the model would not run as expected.


\section{Pseudocode to TLA$^{+}$}

Instead of converting from pseudocode to TLA$^{+}$, I used a set of instructions for both algorithms. Both of these specified the behavior for when a process $p$ wakes up or detects a leader to be dead. As we have assumed that processes that die are removed, there has been no need to model the waking up of a process, thus leaving us only with an option to create a function like \textit{CheckLeader} (Figure \ref{checkleader}.)

However, the approach of using a set of instructions like this, rather than a specific pseudo code has left a lot of ambiguity and things to be interpreted. While this may not seem the case at first glance, a few things aren't specified. Such as in the Ring Algorithm set of instructions (to be called pseudocode from here on), it is not specified when each process should toggle their \textit{participation} status. Neither is it clear to see what the purpose of the \textit{participation} variable is in general. The instruction set does not say at any point that something isn't allowed if a process isn't participating. This along with smaller things both from the Ring Algorithm and the Bully Algorithm has left a lot of interpretation work to do. Although it seems to me that the implementations of both algorithms should work, and follow the pseudocode in a way that makes sense, it does not work, and this might be the fault of too much interpretation work. It is specifically important that everything is modelled in TLA$^{+}$ as it explores every possibility, thus, if some edge case is not described in the pseudocode, and therefore hasn't been implemented, it might be the fault of the model checker not leading to a successful termination state.


\chapter{Conclusion}

\begin{callout}
  Missing
  \end{callout}

In this project we have implemented the Bully Algorithm and the Ring Algorithm for leader election. The algorithms have been implemented in the language TLA$^{+}$, which is a formal specification language used for designing, modelling, documentation and verification of programs.


\bibliography{bibliography}

\appendix

\chapter{Bully Algorithm TLA$^{+}$ model}



\chapter{Ring Algorithm TLA$^{+}$ model}


\end{document}

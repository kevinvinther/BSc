\documentclass{report}

\usepackage[a4paper]{geometry} % paper size, margins etc.

\usepackage{tlatex}
\usepackage{listings}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{lipsum}

\usepackage[most]{tcolorbox}
\usepackage{fontawesome}
\usepackage{xcolor}
\usepackage{enumitem} % Add the possibility of removing indentation in enumerate
\usepackage{multicol}

\usepackage{algorithm2e}

\definecolor{mycolor}{RGB}{242,87,87}
\definecolor{green}{RGB}{123, 224, 173}
\definecolor{yellow}{RGB}{255, 220, 94}
\definecolor{offwhite}{RGB}{248,236,224}
\newcommand*{\sans}{\fontfamily{lmss}\selectfont}

\newtcolorbox{callout}{
  enhanced,
  colback=mycolor,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutgreen}{
  enhanced,
  colback=green,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\newtcolorbox{calloutyellow}{
  enhanced,
  colback=yellow,
  coltext=offwhite, % color of the text
  boxrule=0pt,
  leftrule=3pt,
  colframe=white,
  sharp corners,
  left=20pt,
  fontupper=\sffamily, % change font to sans-serif
  overlay unbroken and first={
    \node[anchor=west, xshift=5pt, text=offwhite] at (frame.west) {\faBellO}; % color of the icon
  },
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength\headheight{12pt}
\rhead{\includegraphics[width=1cm]{sdu_mini.png}}



\begin{document}
\begin{center}

       \includegraphics[scale=0.3]{sdu.png}

       \vspace*{1cm}
       \textbf{\Large Formal verification of distributed leader election algorithms with model checking
       }\\


       \vspace{0.4cm}
       June 1, 2023

       \vspace{0.5cm}

       \vspace{1.5cm}
       \begin{multicols}{2}
       \textsc{Student}\\
       \textbf{Kevin Joshua Vinther}\\
       \textit{kevin20@student.sdu.dk}
       \vspace{0.5cm}
       \\
       \textsc{Supervisor}\\
       \textbf{Marco Peressotti}\\
       \textit{Peressotti@imada.sdu.dk}
       \end{multicols}
       \vspace{2cm}

       \vfill
       Department of Mathematics and Computer Science \\
       University of Southern Denmark, SDU.


       \vspace{0.8cm}

\end{center}

\thispagestyle{empty}

\newpage

\setcounter{page}{1}

\tableofcontents
\chapter{Introduction}


Today, more than ever before, distributed systems play a crucial role in computer infrastructure. However, they are also notoriously difficult to implement correctly. Even with only a few interacting processes in a distributed system, it can lead to a tremendous amount of states. Catching each bug and edge case in the many possible states can take an enormous amount of time, and be exceedingly challenging.

Distributed leader election is a distributed algorithm which requires that all processes in a distributed system agree on one specific process as their leader. This is crucial for many modern systems as distributed algorithms are typically not completely symmetrical, and therefore some process has to take the lead in initiating the algorithm. Leader election can find a leader, to become this process which initiates the algorithm \cite{kshemkalyani2011distributed}.

It is a challenge to verify that distributed algorithms work as intended in a distributed system using conventional tools today. Therefore, we use techniques from formal verification methods, because they help us test distributed algorithms in a way that no conventional tool can.

We seek to verify the correctness of two distributed leader election algorithms: the Bully Algorithm and the Ring Algorithm\footnote{The Ring Algorithm is a familiar name for the Lelang, Chang and Roberts algorithm (also known as LCR). We will continue to use the name ``Ring Algorithm''.}.

We do this using techniques from formal methods to check if there are any bugs, concurrency issues and security issues in the algorithm. Throughout this project the TLA$^{+}$ (Temporal Logic of Actions Plus) verification suite is used to model and verify the Ring and Bully Algorithm.

In the TLA$^{+}$ verification suite, the TLC model checker is included. The model checker verifies the correctness of the algorithm by going through each possible state, and making sure that it produces satisfiable behavior, thus verifying if an algorithm works even in the cases that are hard to find using conventional tools \cite{10.1007/3-540-48153-2_6}.

The goal of this project is to have modeled both the Bully Algorithm and the Ring Algorithm in the TLA$^{+}$ specification language, and have tested them using the TLC model checker to verify if they are correct.

\chapter{Overview}

\section{Leader Election}

In several algorithms for distributed systems, a process may posses the role of the \textit{leader}. Usually a leader may be required because distributed algorithms typically are not completely symmetrical. Thus, the leader can take the lead in initiating the algorithm.

The aim of an algorithm for the Leader Election problem is to elect a leader from a set of processes in a way that all processes can agree on the same leader. It is crucial that all processes agree on the same leader, as if one process has the wrong leader, it can lead to many issues, such as failures in the system.

%This \textit{report?} will search to implement two leader election algorithms: The \textit{Bully Algorithm} and the \textit{Ring Algorithm}\footnote{Also known as the Lelang, Chang and Roberts (LCR) algorithm, but commonly referred to as the Ring algorithm, as will be done in this \texit{report?}}
%This should probably be discussed in the introduction.

This project focuses on the Bully Algorithm and the Ring Algorithm. The Ring Algorithm works on a complete graph, with an undirected ring superimposed. The Bully Algorithm works on a complete undirected graph.
\\\\
\noindent
For both the Bully and Ring Algorithm we assume that:
\begin{itemize}
  \item The network is reliable. Messages do not get lost.
  \item Nodes may fail at any time, including the leader.
  \item Fail-stop model. Failed nodes are removed from the system forever.
  \item Messages are asynchronous.
\end{itemize}


\section{Bully Algorithm}

In the Bully Algorithm, the elected leader will either be the leader with the lowest \textit{id}, or the highest ID. In this project, we assume that the leader is the process with the highest id.

In the algorithm, there exists three different types of messages to be sent and received. These messages initiate behavior on the receiving process, depending on what the contents of the message is. The messages are:
\begin{itemize}
  \item \textit{election}: sent to announce an election.
  \item \textit{alive}: sent to respond to an \textit{election} message from a lower id.
  \item \textit{victory}: sent by winner to announce victory.
\end{itemize}

Rather than traditional pseudocode, we base ourself on a series of instructions (which throughout the report will be referred to as pseudocode.)

When a process $p$ recovers from failure, or the failure detector indicates that the current leader has failed, $p$ performs the following actions:

\begin{enumerate}
\item If $p$ has the highest process \textit{id}, it sends a \textit{victory} message to all other processes and becomes the new leader. Otherwise, $p$ broadcasts an \textit{election} message to all other processes with higher process \textit{id}s than itself.
\item If $p$ receives no \textit{alive} after sending an \textit{election} message, then it broadcasts a \textit{victory} message to all other processes and becomes the leader.
\item If $p$ receives an \textit{alive} from a process with a higher \textit{id}, it sends no further messages for this election and waits for a \textit{victory} message. (If there is no \textit{victory} message after a period of time, it restarts the process at the beginning.)
\item If $p$ receives an \textit{election} message from another process with a lower \textit{id} it sends an \textit{alive} message back and if it has not already started an election, it starts the election process at the beginning, by sending an \textit{election} message to higher-numbered processes.
\item If $p$ receives a \textit{victory} message, it treats the sender as the leader.
\end{enumerate}

\section{Ring Algorithm}

Unlike the Bully Algorithm, the Ring Algorithm assumes a superimposed undirected ring. This means that we assume the processes to be in a ring, and model the implementation from this assumption.
\\\\
\noindent
In the Ring Algorithm, there exists two different types of messages:
\begin{itemize}
  \item \textit{probe(id)}: sent to search for the leader.
  \item \textit{selected(id)}: sent to announce the result.
\end{itemize}

You will notice in the messages, that, unlike in the Bully Algorithm, they have an attached \textit{id}. While it may read as if it is a function, it is just an attachment to the message. The \textit{id} is used to identify who originally sent the message.

Furthermore, the Ring Algorithm requires a \textit{boolean} variable, called \textit{participate}. The variable indicates whether or not process $P_{i}$ participates in the election.

Like in the Bully Algorithm, we base ourself on a set of instructions rather than traditional pseudocode.

\noindent
When process $P_{i}$ wakes up to participate in the election:
\begin{enumerate}
  \item Send \textit{probe(i)} to right neighbour
        \item \textit{participate }$\leftarrow $ \textsc{True}
\end{enumerate}

\noindent
When \textit{probe(k)} message arrives from the left neighbour $P_{j}$:
\begin{enumerate}
  \item If \textit{participate} = \textsc{False} then \textit{participate} $\leftarrow$ \textsc{True}.
  \item if $i > k$ then discard the probe
  \item else if $i < k$ then forward \textit{probe(k)} to right neighbor
  \item else if $i = k$ then declare $i$ is the leader; circulate \textit{selected(i)} to right neighbour;
\end{enumerate}

\noindent
When a \textit{selected(x)} message arrives from left neighbour:
\begin{enumerate}
  \item if $x \neq i$ then note $x$ as the leader and forward message to right neighbor
        \item else do not forward the \textit{selected} message.
\end{enumerate}

In this algorithm, like in the Bully Algorithm, we assume that the leader will be the process with the highest id alive.

\chapter{Bully Algorithm}

\section{Converting to TLA+}
Since we have based ourself on an instruction set rather than pseudocode for what process $p$ should do, it has been more of a process of modelling the algorithm correctly, rather than converting it from pseudocode.

The second point in the algorithm described earlier states that, if process $p$ receives no \textit{alive} message after sending an Election message, it then broadcasts a \textit{victory} message to all other processes. Since TLA$^{+}$ does not allow for waiting a specified amount of time, and we assume a \textit{fail-stop} model, instead of waiting to see, it immediately checks if process P is the process with the highest ID alive, and broadcasts a \textit{victory} message if this is the case. We allow ourself this because the \textit{fail-stop} model assumes that all processes will know the failure of other processes, but it is not specified how. Therefore, we can assume that the process will know that it is the process with the highest \textit{id} alive. This is also done in the beginning of the algorithm, when a process checks if a leader is dead.

Furthermore, I have made a modification to point 4. However, as this is not done because of limitations of TLA$^{+}$, it is discussed in Section \ref{bullyreceivemessagessection}.
\section{Setup}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} ProcessID \.{\times} \{\@w{ELECTION} ,\,\@w{ALIVE}
 ,\,\@w{VICTORY} \}}%
\@pvspace{8.0pt}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto}}%
\@x{\@s{109.06} [ ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\fl{}\bottombar\cl{}

\caption{Setup for the Bully Algorithm}
\label{bullysetup}
\end{figure}

Before modeling the behavior of the specification, we set up the constants, variables and initialize them in the \textit{Init} function. Looking at the specification for the algorithm, we need to model processes and messages.

The algorithm assumes a complete undirected graph. We model this by creating a \textbf{State} variable, which contains a record of all \textit{processes} and their fields. We define the \textbf{State} variable to be a sequence of records, each of which hold the following metadata in its fields (Figure \ref{bullysetup}):
\begin{itemize}
    \item \textit{ID}: The process has a unique ID. $ID \in ProcessID$, where $ProcessID$ is the total number of processes, defined as a range from 1 to the natural number N.
    \item \textit{Condition}: A process is either dead or alive (called \textit{active}). Condition $\in$ \{{\sans"Dead", "Active"}\}
    \item \textit{Leader}: The process should know who its leader is. The leader may be the process itself. $Leader \in ProcessID$
    \item \textit{Participating}: The process is either participating in the election or not. $Participating \in$ {\small \textsc{Boolean}}
\end{itemize}
Furthermore, we define a sequence, \textbf{MessageBox} which holds every processes received messages. The MessageBox maps from each process, $p$ initially to an empty tuple, and when messages are received, a sequence of messages. These tuples are the \textbf{Message}s. We define a \textbf{Message} as ProcessID $\times$ \{{\sans ``ELECTION'', ``ALIVE'', ``VICTORY''}\}, thus an example of an {\sans ``ELECTION''} message from process $1$ is: $\langle1,$ {\sans ``ELECTION''} $\rangle$.

\section{Sending Messages}


\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Sending Messages}\moduleRightDash\@xx{}%

\@x{ SendAliveAndTail ( p ,\, q ) \.{\defeq}}%
 \@x{\@s{16.4} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q
 ]\@s{0.25} \.{=} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{ALIVE}
 {\rangle} ) ,\,}%
\@x{\@s{185.43} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{ SendVictory ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{49.19} {\IF} q \.{\neq} p \.{\land} State [ q ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{49.19} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{VICTORY} {\rangle} )}%
\@x{\@s{49.19} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendVictoryAndTail ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
\@x{\@s{32.8} {\IF} State [ q ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} {\IF} q \.{=} p \.{\THEN} Tail ( MessageBox [ q ] )
 \.{\ELSE} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{VICTORY}
 {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendElection ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{32.8} {\IF} q \.{\in} HigherIDs ( p ) \.{\land} State [ q ] .
 Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{ELECTION} {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%


\fl{}\bottombar\cl{}

\caption{The \textit{sender} functions}
\label{bullysendingmessages}
\end{figure}

We earlier defined the \textbf{MessageBox} to be a sequence of \textbf{Message}s. This makes the handling of messages extremely convenient. One of the core operations we make with messages are sending them. To send a message from process $p$ to process $q$ with the contents {\sans ELECTION}, we simply append the tuple $\langle p, $ {\sans ``ELECTION''} $\rangle$ to \textit{MessageBox[q]}. In TLA$^{+}$ this is done like so:
\begin{lstlisting}
MessageBox'
     = [MessageBox EXCEPT ![q] = Append(<<p, ''ELECTION''>>)]
\end{lstlisting}
This defines the MessageBox variable to have $\langle p, $ {\sans ``ELECTION''} $\rangle$ appended to \textit{MessageBox[q]} in the next state.

In the sender functions (Figure \ref{bullysendingmessages}) you will notice two different types of sending functions: one which is simply ``SendX'', and one which is ``SendXAndTail''. The AndTail variant does the same as SendX, except it also removes the newest message in process $p$'s inbox. This is done as to not clutter the inbox with irrelevant messages.

As discussed earlier, there are three different messages in the bully algorithm: \textit{alive}, \textit{victory}, and \textit{election}.

The \textit{alive} message is only sent in a case where a process receives an \textit{election} message from a process with a lower id. Thus, no additional work is needed other than process $q$ should receive an \textit{alive} message from process $p$. This job is done by the \textit{SendAliveAndTail} function. Since it is an ``AndTail'' function it also removes the newest message by setting the message box of $p$ to be the tail of the message box.

The \textit{SendVictory} function is similar, only it sends the \textit{victory} message to all processes except the sender. We assume a fail-stop model, meaning that the other processes learn when a process dies, allowing us to send only to the alive processes. This function also has a ``AndTail'' variant, which is identical except it tails $p$'s message box.

\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{MaxAliveID}\moduleRightDash\@xx{}%
\@xx{}%
\@x{ MaxAliveID \.{\defeq} {\CHOOSE} id \.{\in} ProcessID \.{:}}%
 \@x{\@s{80.15} \A\, p \.{\in} ProcessID \.{:} State [ p ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{163.18} \.{\lor} id \.{\geq} State [ p ] . ID}%
\fl{}\bottombar\cl{}

  \caption{Function that returns the highest ID alive}
  \end{figure}

\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{HigherIDs}\moduleRightDash\@xx{}%
 \@x{ HigherIDs ( p ) \.{\defeq} \{ q \.{\in} 1 \.{\dotdot} MaxAliveID \.{:} q
 \.{>} p \}}%
\fl{}\bottombar\cl{}
\label{higherids}
  \caption{Function which returns all IDs higher than $p$}
\end{figure}

Similar to the \textit{victory} message, the \textit{election} message is sent to a select group of processes. This time it's all processes with a higher ID than $p$. This is achieved using a helper function \textit{HigherIDs} (see figure \ref{higherids}.)

\section{Handling Received Messages} \label{bullyreceivemessagessection}


\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Handle Received Messages}\moduleRightDash\@xx{}%

 \@x{ ReceiveAlive ( p ,\, q ) \.{\defeq} \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
\@y{\@s{0}%
 Make sure they are already participating
}%
\@xx{}%
\@x{\@s{98.58} \.{\land} p \.{>} q}%
 \@x{\@s{98.58} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ]}%
\@y{\@s{0}%
 No longer participate
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ReceiveElection ( p ,\, q ) \.{\defeq}\@s{4.1} \.{\lor} \.{\land} p
 \.{=} MaxAliveID}%
\@x{\@s{126.95} \.{\land} SendVictoryAndTail ( p )}%
 \@x{\@s{126.95} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\,}%
\@x{\@s{244.46} {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{115.84} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
 \@x{\@s{126.95} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating
 \.{=} {\TRUE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
\@x{\@s{149.18} \.{\land} {\UNCHANGED} State}%
 \@x{\@s{138.07} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
 \@x{\@s{149.18} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
 \@x{ ReceiveVictory ( p ,\, q ) \.{\defeq} State \.{'} \.{=} [ State
 {\EXCEPT} {\bang} [ p ] . Leader \.{=} q ]}%
\@y{\@s{0}%
 Set the leader of receiver to \ensuremath{p} sender
}%
\@xx{}%


\fl{}\bottombar\cl{}

\caption{Message Handlers}
\label{messagehandlers}
\end{figure}

When a message is received, a process will periodically use the \textit{HandleMessages} function to check its messages. This will then execute the correct functions depending on the message. The functions in Figure \ref{messagehandlers} describe the behavior when receiving a specific message.

Points 3, 4, and 5 from the pseudocode describe what to do when receiving messages:

\begin{enumerate}
  \setcounter{enumi}{2}
  \item If P receives an alive from a process with a higher \textit{id}, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)
  \item If P receives an Election message from another process with a lower ID it sends an alive message back and if it has not already started an election, it starts the election process at the beginning, by sending an Election message to higher-numbered processes.
  \item If P receives a victory message, it treats the sender as the leader.
\end{enumerate}

The function \textit{ReceiveAlive} (Figure \ref{messagehandlers}) addresses point 3. It checks if the message is from a higher id than itself, and if so, it modifies its participation status to be \textsc{False}.

The function \textit{ReceiveElection} addresses point 4. However, you may notice that it does not correctly follow point 4. Point 4 explicitly states that \textbf{``...if it has not already started an election, it starts the elction process at the beginning, by sending an Election message to higher-numbered processes''}. Instead of doing this, it only sends an alive message, and, if its own participation status is \textsc{False}, it sets it to be \textsc{True} instead. This change is done because it will only lead to a number of irrelevant \textit{election} messages. Furthermore, we have deviated from point 4 in the sense that we check if the process has the highest ID alive, and if so, it declares victory. This is done because we assume a fail-stop model.

The \textit{ReceiveVictory} function addresses point 5 by setting the leader to the sender of the \textit{victory} message.


\section{Delegating Functions with HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Delegate Messages}\moduleRightDash\@xx{}%

\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{93.62} sender \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{93.62} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{93.62} \.{\IN}}%
\@x{\@s{97.72} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{97.72} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{4.1}}%
\@y{\@s{0}%
 Message box shouldn\mbox{'}t be empty
}%
\@xx{}%
\@x{\@s{97.72} \.{\land} \.{\lor} \.{\land} msg \.{=}\@w{VICTORY}}%
\@y{\@s{0}%
 If the message is \ensuremath{VICTORY
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} State [ sender ] . Condition \.{=}\@w{Active}}%
\@x{\@s{119.95} \.{\land} ReceiveVictory ( p ,\, sender )}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@y{\@s{0}%
 Remove all messages, so that the election does not run forever.
}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ELECTION}}%
\@y{\@s{0}%
 If the message is \ensuremath{ELECTION
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} State [ sender ] . Condition \.{=}\@w{Active}}%
\@x{\@s{119.95} \.{\land} ReceiveElection ( p ,\, sender )}%
\@y{\@s{0}%
 Tail is done incide \ensuremath{ReceiveElection
}}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ALIVE}}%
\@y{\@s{0}%
 If the message is \ensuremath{ALIVE
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} State [ sender ] . Condition \.{=}\@w{Active}}%
\@x{\@s{119.95} \.{\land} ReceiveAlive ( p ,\, sender )}%
\@y{\@s{0}%
 Handle in \ensuremath{ReceiveAlive
}}%
\@xx{}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%


\fl{}\bottombar\cl{}

\caption{Delegating Functions}
\label{handlemessages}
\end{figure}

In the \textit{Next} state relation of the specification, one of the actions a process can take is to check its messages. This is done via the \textit{HandleMessages} function. If process $p$ has any messages in their inbox, one of 4 things can happen, depending on the type of message or the condition of the sender.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]
  \item If the sender is dead, we ignore the message and remove it from the inbox of process $p$.
  \item If the content of the message is \textit{victory}, we delegate work to the \textit{ReceiveVictory} function and remove all messages from process $p$ because we do not care about other message at this point, as the election is done.
  \item If the content of the message is \textit{election}, we delegate the rest of the work to the \textit{ReceiveElection} function.
  \item If the content of the message is \textit{alive}, we delegate work to the \textit{ReceiveAlive} function and remove the message from the inbox of process $p$.
\end{enumerate}

\section{Checking the leader condition}

\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Check Leader}\moduleRightDash\@xx{}%

\@xx{}%
 \@x{ CheckLeader ( p ) \.{\defeq}\@s{8.2} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{96.12} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{96.12} \.{\land} \.{\lor} \.{\land} p \.{=} MaxAliveID}%
\@x{\@s{118.35} \.{\land} SendVictory ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\, {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{107.24} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
\@x{\@s{118.35} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
\@x{\@s{118.35} \.{\land} SendElection ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%


\fl{}\bottombar\cl{}

\caption{Checking the condition of the leader}
\label{checkleader}
\end{figure}

One of the actions a process can take in the \textit{next} state relation is to check the condition of the leader.
In the pseudocode, it is specified that ``When a process P recovers from failure, or the failure detector indicates that the current leader has failed...''. Since we assume that the processes do not recover from failure we use the \textit{CheckLeader} (Figure \ref{checkleader}) function instead.

The function only runs if the process checking is active, and the leader is dead. If the process is active, the function checks whether process $p$ is the process with the highest id. If $p$ has the highest id, it sends a \textit{victory} message, and declares itself the new leader. If $p$ is not the process with the highest id, we first make sure that it is not currently participating in any election, as to not accidentally start multiple elections in one cycle. Then process $p$ sends an election message, and sets its own Participation status to \textsc{True}, as it is now in an election.


\section{Next state relation and killing the leader}
\begin{figure}

\tlatex
\@x{}\moduleLeftDash\@xx{NextPredicateAndKillLeader}\moduleRightDash\@xx{}%

\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ,\, {\bang} [ MaxAliveID ] .
 Participating \.{=} {\FALSE} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 CheckLeader ( p ) \.{\lor} HandleMessages ( p )}%

\fl{}\bottombar\cl{}
\caption{Next state relation and KillLeader}
\label{nextpredkillleader}
\end{figure}

The Next state relation (Figure \ref{nextpredkillleader}) chooses what should happen in the next state.
For this specification there are two options: Either, the leader is killed, or a process handles its messages or checks its leaders status.

In case the choice is made to kill the leader, we make sure that the leader sees itself as the leader, and if they do, we change its condition in the next state to be dead and its participation status to be \textsc{False}, effectively killing it. This is only done if there are 2 or more processes alive, as there is no reason to initiate a leader election when there is only one process.

In case the decision to kill the leader is not chosen, some process is chosen to make a choice of what it wants to do. The process either checks its leader or handles its messages.


\section{Invariants and properties}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Invariants and Properties}\moduleRightDash\@xx{}%

\@x{}%
\@y{\@s{0}%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Each variable should be within the type constraints
}%
\@xx{}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Every process should have a unique \ensuremath{ID
}}%
\@xx{}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If a process is participating in the election, then it should not be the
 leader
}%
\@xx{}%
 \@x{ Participating \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{=} {\TRUE} \.{\implies} State [ p ] . Leader \.{\neq} p}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{\@s{0}%
 Properties
}%
\@xx{}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{16.0pt}%
\@x{}%
\@y{\@s{0}%
 The highest alive process should become the leader
}%
\@xx{}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{16.4} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} State [ p ] . Participating \.{=} {\FALSE}}%


\@x{}\bottombar\@xx{}%

  \caption{Invariants and Properties in the Bully Algorithm}
  \label{bullyinvariantsproperties}
  \end{figure}

\textbf{Invariants}\\
\noindent
In TLA$^{+}$, an \textit{invariant} is a statement that must be true on every state of the program. \cite{Wayne} One common type of invariant is the \textit{TypeOK} invariant (Figure \ref{bullyinvariantsproperties}). \textit{TypeOK} makes sure that the types never go out of a specified domain or change to an unwanted value. In the case of this specification this is true for the \textit{State} and \textit{MessageBox} variables. For the \textit{State} variable, it will hold true that:
\begin{itemize}
  \item A process' \textit{id} is a part of the \textit{ProcessID} set.
  \item A process' condition is either \textit{Active} or \textit{Dead}.
  \item A process' \textit{leader} is a part of the \textit{ProcessID} set.
  \item A process' participation status is a \textsc{Boolean}.
\end{itemize}
For the message box it holds that each ID will map to a sequence of messages.

In this specification, we also have an invariant called \textit{UniqueID} which makes sure that no two processes hold the same ID. Furthermore, we also have an invariant called \textit{Participating} which states that, if a process is participating in an election, it cannot be the leader itself, or see itself as leader.
\\\\
\noindent
\textbf{Properties}\\
\noindent
There are two kinds of temporal properties: safety properties, and liveness properties. Safety properties make sure that the system doesn't do bad things, and liveness makes sure our system always does a good thing.\cite{Wayne}

We have three properties: two safety properties and one liveness property. The safety properties are \textit{ElectionTerminationImpliesSameLeader}, and \textit{HighestAliveProcessIsLeader}. \textit{ElectionTerminationImpliesSameLeader} ensures that when two processes that have been in an election eventually get out of the election, they will have the same leader. \textit{HighestAliveProcessIsLeader} ensures that if a process is not participating in an election, its leader is the process with the highest id alive.

The liveness property, \textit{ElectionWillEnd} ensures that an election will eventually end, such that it does not just run forever.

\section{Temporal Formula}

\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Temporal Formula}\moduleRightDash\@xx{}%

 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%

\@x{}\bottombar\@xx{}%

\caption{Temporal Formula}
\label{bullyspec}
\end{figure}


To run the specification with the model checker, the temporal formula in Figure \ref{bullyspec} is used. The reason a temporal formula is used rather than just specifying the initial predicate and next-state relation is to use \textit{strong fairness}. Without strong fairness, the model checker might just decide to stop the entire system. That is an intended feature, but it is not what we want. Strong fairness ensures that if an action is always enabled, it eventually happens.\cite{Wayne_2020}


\chapter{Ring Algorithm}


\section{Similarities to Bully Algorithm}
The Ring Algorithm and the Bully Algorithm are both similar in many ways. Since both algorithms are algorithms on graphs, we can reuse a lot of the setup. The Ring Algorithms superimposed overlay is an undirected ring. We will not need to model it is a ring, even though it is a ring. Instead, we assume it to be a ring, and write the specification as if it was a ring.


\section{Setup}

\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{Setup}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} \{\@w{PROBE} ,\,\@w{SELECTED} \} \.{\times}
 ProcessID}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Initializes the variables: \ensuremath{State} and \ensuremath{MessageBox
}}%
\@xx{}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto} [}%
\@x{\@s{109.06} ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%

\@x{}\bottombar\@xx{}%

  \caption{The Setup for the Ring Algorithm}
  \label{ringsetup}
\end{figure}

The setup (Figure \ref{ringsetup}) for the Ring Algorithm is almost identical to that of the Bully Algorithm. The only difference is how we define the \textbf{Message}s. A message in the Ring Algorithm has been changed in two ways. First, we don't send the same messages in the Ring Algorihtm. The messages in the Ring Algorithm are \textit{probe} and \textit{selected}. Second, we switch the order of message and process. In the Bully Algorithm it made sense to have the ProcessID as the first part of the message, since it is the sender of the message. In the Ring Algorithm, the process id is the ID of the message, and not the sender. Since both messages in the Ring Algorithm have an ID attached to them, the messages instead have the process on the right side. However, this is purely a syntactic choice.


\section{Neighbours and Sending Messages}

\begin{figure}

  \tlatex
\@x{}\moduleLeftDash\@xx{Neighbour}\moduleRightDash\@xx{}%
\@x{ Neighbour ( p ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} AliveProcesses \.{\defeq} \{ q \.{\in} ProcessID \.{:}
 State [ q ] . Condition \.{=}\@w{Active} \}}%
\@x{\@s{16.4} \.{\IN}}%
 \@x{\@s{16.4} {\IF} p \.{=} MaxAliveID \.{\THEN} {\CHOOSE} q \.{\in}
 AliveProcesses \.{:} {\TRUE} \.{\ELSE}}%
\@x{\@s{51.73} {\CHOOSE} neighbour \.{\in} AliveProcesses \.{:}}%
\@x{\@s{94.51} \.{\land} p \.{<} neighbour}%
 \@x{\@s{94.51} \.{\land} \A\, q \.{\in} AliveProcesses \.{:} q \.{\leq} p
 \.{\lor} neighbour \.{\leq} q}%


\@x{}\bottombar\@xx{}%

  \caption{Neighbour function}
  \label{ringneighbour}
\end{figure}
\begin{figure}
\tlatex
\@x{}\moduleLeftDash\@xx{SendingMessages}\moduleRightDash\@xx{}%
\@x{ SendMessageAndTailMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,}%
\@x{\@s{126.26} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Simple \ensuremath{SendMessage}. Sends message \ensuremath{msg} to
 \ensuremath{q} with \ensuremath{id} \ensuremath{id}.
}%
\@xx{}%
\@x{ SendMessage ( q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{61.65} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ]}%
\@pvspace{8.0pt}%
\@x{ SendMessageAndEmptyMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%


\@x{}\bottombar\@xx{}%
\caption{Sending Messages}
\label{ringsendingmessages}
\end{figure}

\noindent
\textbf{Neighbour}\\
\noindent
In a ring topology, each process has a left-side neighbour and a right-side neighbour. For the Ring Algorithm we only care about the right-side neighbour. Thus, the \textit{Neighbour} function (Figure \ref{ringneighbour}) returns the right-side neighbour. It does this first by checking if the process asking for its neighbour is the process with the highest id alive, and if so it returns the lowest id alive. Otherwise, it uses \textsc{Choose} to choose the process whose id is higher than p, but lower than every other process whose id is higher than p, i.e. the neighbour.
\\\\
\noindent
\textbf{Sending Messages}\\
\noindent
We deviate a lot from the Bully algorithm in how messages are sent. Instead of having functions for specific messages, we have two functions \textit{SendMessage}, \textit{SendMessageAndTailMessageBox} and \textit{SendMessageAndEmptyMessageBox} (Figure \ref{ringsendingmessages}). In the Bully Algorithm, a lot had to be done when sending each message. In the Ring Algorithm, messages are only sent to neighbours, thus requiring less work choosing who to send to. In the Bully Algorithm this work was done in the sender functions, but this work is not needed in the Ring Algorithm.

The \textit{SendMessage} function updates the MessageBox of a process with a Message. The \textit{SendMessageAndTailMessageBox} is similar, except it also removes the first message in the MessageBox of $p$. This is done because the \textit{HandleMessages} function requries both sending messages and deleting in the same state. However, in TLA$^{+}$ you cannot update a variable twice in the same state, thus requiring a function like \textit{SendMessageAndTailMessageBox} to update both message boxes at the same time. \textit{SendMessageAndEmptyMessageBox} is similar to \textit{SendMessageAndTailMessageBox}, but instead of deleting just the first message, it deletes all messages.






\section{HandleMessages}
\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{HandleMessages}\moduleRightDash\@xx{}%

\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{49.19} id \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{49.19} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{49.19} \.{\IN}}%
\@x{\@s{49.19} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
\@y{\@s{0}%
 Only if the process is active
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{43.80}}%
\@y{\@s{0}%
 The message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} \.{\lor} \.{\land} State [ id ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{71.42} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{71.42} \.{\land} {\UNCHANGED} State}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{PROBE}}%
\@y{\@s{0}%
 If the message is \ensuremath{PROBE
}}%
\@xx{}%
 \@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@y{\@s{0}%
 Make sure the participation status is \ensuremath{{\TRUE}
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} State [ p ] . Participating \.{=} {\TRUE}}%
\@x{\@s{93.64} \.{\land} {\UNCHANGED} State}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{=} id}, send \ensuremath{SELECTED
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, p ,\,\@w{SELECTED} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id\@s{4.1} \.{\land} State [ p ] .
 Participating \.{=} {\FALSE}}%
\@y{\@s{0}%
 If \ensuremath{p \.{>} id} ignore message
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, p ,\,\@w{PROBE} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{<} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{<} id} send probe to \ensuremath{neighbour
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, id ,\,\@w{PROBE} )}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{SELECTED}}%
\@y{\@s{0}%
 If the message is \ensuremath{SELECTED
}}%
\@xx{}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{\neq} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{\neq} id}, then send \ensuremath{SELECTED} to
 \ensuremath{neighbour
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, id ,\,\@w{SELECTED} )}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 if \ensuremath{p \.{=} id} then declare itself the leader
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%

\@x{}\bottombar\@xx{}%

  \caption{HandleMessages}
  \label{ringhandlemessages}
  \end{figure}

Instead of having separate functions for handling the different messages, all of this is done in the \textit{HandleMessages} function (Figure \ref{ringhandlemessages}).

The function checks if there are any messages for process $p$, and then proceeds to check what kind of message the first message is.
\\\\
\noindent
\textbf{Receiving a \textit{probe} message}\\
\noindent
In case the message received is \textit{probe}, we check first if process $p$ is participating. If it is not, we change the \textit{participating} field to be true.

Afterwards, we compare $p$ with the \textit{id} from the message.
If $p = id$, then the probe has circled around all processes, and we send the \textit{selected} message to the neighbour. The message box of $p$ is then emptied. We empty the message box to ensure that there aren't any excess messages that will harm the election.\\
If $p > id$, we deviate from the original pseudocode. The original pseudocode states that: ``if p $>$ id, discard the probe.'' However, this leads to cases with infinite loops of \textit{probe} messages. Thus, instead what we do is, if $p > id$ and $p$ is not participating in the election, we send a new \textit{probe} message with $p$ as the id, so that it can become the leader. If $p$ however is participating, we just discard the message.\\
If $p < id$ we send the probe to the right  neighbour, and delete the message.
\\\\
\noindent
\textbf{Receiving a \textit{selected} message}\\
\noindent
In case the msg is \textit{selected} we do not need to check whether or not the process is participating in the election, as they will have participated no matter what, as the \textit{probe} message has been all around the ring. If the $id \neq p$ then we note $id$ to be the leader and set our participation status to be \textsc{False}. We also send the \textit{selected} message to our right neighbour, so that everyone knows who the new leader is. However, if $p = id$ then $p$ is the leader, and he is noted as such by himself. There is a slight deviation from the pseudocode here. In the pseudocode it is stated that $p$ is noted by itself to be the leader, when it first sends the \textit{selected} message to its right neighbour. However, due to the limitations of TLA$^{+}$, I have decided against doing it there, as it would require a check of participation in each equality check with the \textit{id} when it receives the \textit{probe} message. This solution is simply easier to look at. The desired outcome will be the same, i.e. every process having the same leader and not being participating.


\section{Checking The Leader Condition}
\begin{figure}
  \tlatex

\@x{}\moduleLeftDash\@xx{CheckLeader}\moduleRightDash\@xx{}%

 \@x{ CheckLeader ( p ) \.{\defeq} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{87.92} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{87.92} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
\@x{\@s{87.92} \.{\land} \.{\lor} \.{\land} MaxAliveID \.{=} 1}%
 \@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} p ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
\@x{\@s{110.15} \.{\land} {\UNCHANGED} MessageBox}%
\@x{\@s{99.04} \.{\lor} \.{\land} MaxAliveID \.{\neq} 1}%
 \@x{\@s{110.15} \.{\land} SendMessage ( Neighbour ( p ) ,\, p ,\,\@w{PROBE}
 )}%
 \@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%


\@x{}\bottombar\@xx{}%

  \caption{CheckLeader}
  \label{ringcheckleader}
  \end{figure}


When we check if the leader is dead in the Ring Algorithm (Figure \ref{ringcheckleader}), we do it a bit differently than in the Bully Algorithm. Here, the only check we, other than to see if the leader is dead, do is to see if there is only one process remaining. If this is the case, we set that one process as the leader, and its participation status to be \textsc{False} ending the election (once and for all). However, if this is not the case, we send a \textit{probe} message to the right neighbour and set $p$s participation status to \textsc{True}.

\section{Next state relation and killing the leader}

\begin{figure}
\tlatex

\@x{}\moduleLeftDash\@xx{Next State Relation and Kill Leader}\moduleRightDash\@xx{}%

\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 HandleMessages ( p ) \.{\lor} CheckLeader ( p )}%

\@x{}\bottombar\@xx{}%

\caption{Next state relation and KillLeader}
\label{ringnextleader}
\end{figure}

KillLeader and the next state relation (Figure \ref{ringnextleader}) are identical to the Bully Algorithm.

\section{Invariants and Properties}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Invariants and Properties}\moduleRightDash\@xx{}%

\@x{}%
\@y{%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{%
 Properties
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} ( {\Diamond} ( State [ p ] . Participating \.{=}
 {\FALSE} ) )}%
\@pvspace{8.0pt}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{28.69} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%


\@x{}\bottombar\@xx{}%
  \caption{Invariants and Properties}
  \label{ringinvariants}
  \end{figure}

The Ring Algorithm does not introduce any new invariants or properties (Figure \ref{ringinvariants}) that the Bully Algorithm does not already have. However, the invariant \textit{Participating} (Figure \ref{bullyinvariantsproperties}) is not present. The Participating invariant does not work in the Ring Algorithm, since it checks whether or not a leader is participating, however, a leader will participate in the election if it receives a \textit{probe} message.
However, all of the other invariants and properties are identical to those of the Bully Algorithm.

\section{Temporal Formula}

\begin{figure}
  \tlatex
\@x{}\moduleLeftDash\@xx{Temporal Formula}\moduleRightDash\@xx{}%
 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%
\@x{}\bottombar\@xx{}%
  \caption{Temporal Formula}
  \label{ringtemporalformula}
  \end{figure}

Like in the Bully Algorithm, the Ring Algorithm also uses a temporal formula (Figure \ref{ringtemporalformula}) rather than stating the initial predicate and the next-state relation in the model checker. Like in the Bully Algorithm, this is done to use \textit{strong fairness}.

\chapter{Evaluation}
\section{The Model Checker}
Both the Ring Algorithm and the Bully Algorithm have been thoroughly checked with the TLC Model Checker, which comes with the TLA$^{+}$ toolbox. The Ring Algorithm has been checked with $n = 1..10$, where $n$ is the number of processes. The Bully Algorithm has been checked with $n = 1..5$. Both algorithms pass the checker without any errors, invariant violations or temporal property violations. As it is the case that there have been no violations from both algorithms with respectively $n = 1..10$ and $n = 1..5$, we can assume it to be true that the models and algorithms are verified to be correct.

You can see the state space progress, with the diameter, number of states found and distinct states for the Ring Algorithm in Table \ref{numstatesmodelcheckerringalgorithm} and for the Bully Algorithm in Table \ref{numstatesmodelcheckerbullyalgorithm}.
\\\\
\noindent
\textbf{Ring Algorithm}\\
\noindent
As you can see in table \ref{numstatesmodelcheckerringalgorithm}, the number of states increase exponentially, but in a way that makes sense. I believe that, although there has been some modifications, the algorithm runs as it should.
\\\\
\noindent
\textbf{Bully Algorithm}\\
\noindent
As you can see in table \ref{numstatesmodelcheckerbullyalgorithm}, the number of states, like the Ring Algorithm rise exponentially, although much faster here. The reason for only going to $n = 5$, rather than $n = 10$ as with the Ring Algorithm is the amount of time it takes for the model checker to be done. With $n = 5$ in the Bully Algorithm it took 8 minutes and 23 seconds, to contrast, it only took 2 seconds with $n = 4$.


\begin{table}[]
  \centering
\begin{tabular}{|l|l|l|l|l|}
\hline
$n$ & Diameter & States Found & Distinct States  \\ \hline
1   & 1        & 1            & 1                \\ \hline
2   & 3        & 3            & 3                \\ \hline
3   & 9        & 17           & 13               \\ \hline
4   & 19       & 66           & 38               \\ \hline
5   & 27       & 232          & 101              \\ \hline
6   & 40       & 773          & 262              \\ \hline
7   & 53       & 2478         & 676              \\ \hline
8   & 69       & 7710         & 1760             \\ \hline
9   & 87       & 23434        & 4584             \\ \hline
10  & 107      & 69923        & 11967            \\ \hline
\end{tabular}
  \caption{Number of states found with the model checker in the Ring Algorithm}
  \label{numstatesmodelcheckerringalgorithm}
\end{table}
\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
$n$ & Diameter & States Found & Distinct States & Queue Size \\ \hline
1   & 1        & 1            & 1               & 0          \\ \hline
2   & 3        & 3            & 3               & 0          \\ \hline
3   & 7        & 50           & 28              & 0          \\ \hline
4   & 14       & 7235         & 2628            & 0          \\ \hline
5   & 29       & 7315267      & 2090268         & 0          \\ \hline
\end{tabular}
  \caption{Number of states found with the model checker in the Bully Algorithm}
  \label{numstatesmodelcheckerbullyalgorithm}
\end{table}

\section{Shortcomings}

The only shortcoming is that only the leader gets killed, and not any of the other processes, in spite of the assumption that any process including (but not limited to) the leader can die. This has been a deliberate choice, as it is enough to show that when a leader dies, the rest of the processes will find a new leader that they can all agree on together.

\section{Pseudocode to TLA$^{+}$}

Instead of converting from what we tratidionally think of as pseudocode to TLA$^{+}$, I used a set of instructions for both algorithms. Both of these specified the behavior for when a process $p$ wakes up or detects a leader to be dead. As we have assumed that processes that die are removed, there has been no need to model the waking up of a process, thus leaving us only with an option to create a function like \textit{CheckLeader}. This is also the reason that the implementation of the Ring Algorithm is so different when the process id is higher than the id in the message. If it was only when the process checked when the leader died, a lot of messages would float around that were of no use.

The approach of using a set of instructions like this, rather than a specific pseudo code has left a lot of ambiguity and things to be interpreted. While this may not seem the case at first glance, a few things aren't specified. Such as in the Ring Algorithm, in the pseudocode it is not specified when each process should toggle their \textit{participation} status back to \textsc{False}. Neither is it clear to see what the purpose of the \textit{participation} variable is in general. The instruction set does not say at any point that something isn't allowed if a process isn't participating. This along with smaller things both from the Ring Algorithm and the Bully Algorithm has left a lot of interpretation work to do. There may be some unseen mistakes that do hinder the algorithm in some way.



\section{Potential Future Changes}

In the Bully Algorithm, we get an enormous amount of states found compared to the Ring Algorithm. A potential reason for this is the way the messages are checked. One of the options when it checks messages it to throw out the message if the sender is dead, rather than just ignoring it. If we instead just checked if the process is dead in each case of messages, it would likely reduce the amount of states drastically. However, there might be some potential issues here, such as deadlocked states where nothing happens because a message will be stuck. But a potential ``fix'' to this, might result in getting a more realistic number of states. Intuitively, the Ring Algorithm does not need to check if a message sender is dead as it comes from the neighbour, and will count no matter what.

The other reason might be something that I have not yet found, but has been a product of the interpretation work. I might have done too much interpretation, and really changed something that I did not think would change anything, or I did not realize to be a change.

\chapter{Conclusion}


In this project we have implemented the Bully Algorithm and the Ring Algorithm for leader election. The algorithms have been modeled in the  TLA$^{+}$ specification language and thoroughly checked with the TLC model checker.

Throughout the implementation of the algorithms, the pseudocode has been followed, but also modified to work correctly with TLA$^{+}$ and our assumption of the \textit{fail-stop} model. As the pseudocode format was a list of instructions rather than traditional pseudocode for both algorithms, some interperation has been done on both algorithms, which may have caused minor problems, such as an excess of states in the Bully Algorithm.

We have assumed a \textit{fail-stop} model, the network to be reliable, and that no nodes can come back to life. This means that any other cases have not been considered such as messages getting lost, processes not learning of other processes deaths, or nodes becoming alive again after being dead.

Both the Ring Algorithm and the Bully Algorithm have been proven to be verifiably correct with the TLC model checker. The model checker for the Bully Algorithm may have found an unreasonable amount of states, but this doesn't affect the correctness of the algorithm. I would have liked to have had more time to find the issue of the number states found, but ultimately the goal of the project has been reached, and I am satisfied with the work done.

\bibliographystyle{abbrv}
\bibliography{bibliography}

\appendix

\chapter{Bully Algorithm TLA$^{+}$ model}
\tlatex
\@x{}\moduleLeftDash\@xx{ {\MODULE} BullyAlgorithm}\moduleRightDash\@xx{}%
\@pvspace{8.0pt}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} ProcessID \.{\times} \{\@w{ELECTION} ,\,\@w{ALIVE}
 ,\,\@w{VICTORY} \}}%
\@pvspace{8.0pt}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto}}%
\@x{\@s{109.06} [ ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Finds the maximum \ensuremath{ID} which is not dead
}%
\@xx{}%
\@x{ MaxAliveID \.{\defeq} {\CHOOSE} id \.{\in} ProcessID \.{:}}%
 \@x{\@s{80.15} \A\, p \.{\in} ProcessID \.{:} State [ p ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{163.18} \.{\lor} id \.{\geq} State [ p ] . ID}%
\@pvspace{8.0pt}%
 \@x{ HigherIDs ( p ) \.{\defeq} \{ q \.{\in} 1 \.{\dotdot} MaxAliveID \.{:} q
 \.{>} p \}}%
\@pvspace{8.0pt}%
\@x{ SendAliveAndTail ( p ,\, q ) \.{\defeq}}%
 \@x{\@s{16.4} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q
 ]\@s{0.25} \.{=} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{ALIVE}
 {\rangle} ) ,\,}%
\@x{\@s{185.43} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{ SendVictory ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{49.19} {\IF} q \.{\neq} p \.{\land} State [ q ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{49.19} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{VICTORY} {\rangle} )}%
\@x{\@s{49.19} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendVictoryAndTail ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
\@x{\@s{32.8} {\IF} State [ q ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} {\IF} q \.{=} p \.{\THEN} Tail ( MessageBox [ q ] )
 \.{\ELSE} Append ( MessageBox [ q ] ,\, {\langle} p ,\,\@w{VICTORY}
 {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
\@x{ SendElection ( p ) \.{\defeq}}%
\@x{\@s{16.4} MessageBox \.{'} \.{=} [ q \.{\in} ProcessID \.{\mapsto}}%
 \@x{\@s{32.8} {\IF} q \.{\in} HigherIDs ( p ) \.{\land} State [ q ] .
 Condition \.{=}\@w{Active}}%
 \@x{\@s{32.8} \.{\THEN} Append ( MessageBox [ q ] ,\, {\langle} p
 ,\,\@w{ELECTION} {\rangle} )}%
\@x{\@s{32.8} \.{\ELSE} MessageBox [ q ] ]}%
\@pvspace{8.0pt}%
 \@x{ ReceiveAlive ( p ,\, q ) \.{\defeq} \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
\@y{\@s{0}%
 Make sure they are already participating
}%
\@xx{}%
\@x{\@s{98.58} \.{\land} p \.{>} q}%
 \@x{\@s{98.58} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ]}%
\@y{\@s{0}%
 No longer participate
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ReceiveElection ( p ,\, q ) \.{\defeq}\@s{4.1} \.{\lor} \.{\land} p
 \.{=} MaxAliveID}%
\@x{\@s{126.95} \.{\land} SendVictoryAndTail ( p )}%
 \@x{\@s{126.95} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\,}%
\@x{\@s{244.46} {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{115.84} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
 \@x{\@s{126.95} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating
 \.{=} {\TRUE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
\@x{\@s{149.18} \.{\land} {\UNCHANGED} State}%
 \@x{\@s{138.07} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@x{\@s{149.18} \.{\land} SendAliveAndTail ( p ,\, q )}%
 \@x{\@s{149.18} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
 \@x{ ReceiveVictory ( p ,\, q ) \.{\defeq} State \.{'} \.{=} [ State
 {\EXCEPT} {\bang} [ p ] . Leader \.{=} q ]}%
\@y{\@s{0}%
 Set the leader of receiver to \ensuremath{p} sender
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Handle messages
}%
\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{93.62} sender \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{93.62} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{93.62} \.{\IN}}%
\@x{\@s{97.72} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
 \@x{\@s{97.72} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{4.1}}%
\@y{\@s{0}%
 Message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{97.72} \.{\land} \.{\lor} \.{\land} State [ sender ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%
\@x{\@s{119.95} \.{\land} {\UNCHANGED} State}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{VICTORY}}%
\@y{\@s{0}%
 If the message is \ensuremath{VICTORY
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveVictory ( p ,\, sender )}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@y{\@s{0}%
 Remove all messages, so that the election does not run forever.
}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ELECTION}}%
\@y{\@s{0}%
 If the message is \ensuremath{ELECTION
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveElection ( p ,\, sender )}%
\@y{\@s{0}%
 Tail is done incide \ensuremath{ReceiveElection
}}%
\@xx{}%
\@x{\@s{108.84} \.{\lor} \.{\land} msg \.{=}\@w{ALIVE}}%
\@y{\@s{0}%
 If the message is \ensuremath{ALIVE
}}%
\@xx{}%
\@x{\@s{119.95} \.{\land} ReceiveAlive ( p ,\, sender )}%
\@y{\@s{0}%
 Handle in \ensuremath{ReceiveAlive
}}%
\@xx{}%
 \@x{\@s{119.95} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@y{\@s{0}%
 Remove first message
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If the leader is found to be dead
}%
\@xx{}%
 \@x{ CheckLeader ( p ) \.{\defeq}\@s{8.2} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{96.12} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{96.12} \.{\land} \.{\lor} \.{\land} p \.{=} MaxAliveID}%
\@x{\@s{118.35} \.{\land} SendVictory ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\FALSE} ,\, {\bang} [ p ] . Leader \.{=} p ]}%
\@x{\@s{107.24} \.{\lor} \.{\land} p \.{\neq} MaxAliveID}%
\@x{\@s{118.35} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
\@x{\@s{118.35} \.{\land} SendElection ( p )}%
 \@x{\@s{118.35} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ,\, {\bang} [ MaxAliveID ] .
 Participating \.{=} {\FALSE} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 CheckLeader ( p ) \.{\lor} HandleMessages ( p )}%
\@pvspace{8.0pt}%
 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{\@s{0}%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Each variable should be within the type constraints
}%
\@xx{}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Every process should have a unique \ensuremath{ID
}}%
\@xx{}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If a process is participating in the election, then it should not be the
 leader
}%
\@xx{}%
 \@x{ Participating \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{=} {\TRUE} \.{\implies} State [ p ] . Leader \.{\neq} p}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{\@s{0}%
 Properties
}%
\@xx{}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{16.0pt}%
\@x{}%
\@y{\@s{0}%
 The highest alive process should become the leader
}%
\@xx{}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{16.4} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} State [ p ] . Participating \.{=} {\FALSE}}%
\@pvspace{8.0pt}%
\@x{}\bottombar\@xx{}%



\chapter{Ring Algorithm TLA$^{+}$ model}
\tlatex
\@x{}\moduleLeftDash\@xx{ {\MODULE} RingAlgorithm}\moduleRightDash\@xx{}%
\@pvspace{8.0pt}%
\@x{ {\EXTENDS} Naturals ,\, FiniteSets ,\, Sequences ,\, TLC}%
\@pvspace{8.0pt}%
\@x{ {\CONSTANT} N}%
\@pvspace{8.0pt}%
\@x{ {\ASSUME} N \.{\in} Nat}%
\@pvspace{8.0pt}%
\@x{ ProcessID \.{\defeq} 1 \.{\dotdot} N}%
\@pvspace{8.0pt}%
\@x{ {\VARIABLES} State ,\, MessageBox}%
\@pvspace{8.0pt}%
 \@x{ Message \.{\defeq} \{\@w{PROBE} ,\,\@w{SELECTED} \} \.{\times}
 ProcessID}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Initializes the variables: \ensuremath{State} and \ensuremath{MessageBox
}}%
\@xx{}%
 \@x{ Init \.{\defeq} \.{\land} State \.{=} [ p\@s{9.46} \.{\in} ProcessID
 \.{\mapsto} [}%
\@x{\@s{109.06} ID \.{\mapsto} p ,\,}%
\@x{\@s{109.06} Condition \.{\mapsto}\@w{Active} ,\,}%
\@x{\@s{109.06} Leader \.{\mapsto} N ,\,}%
\@x{\@s{109.06} Participating \.{\mapsto} {\FALSE} ] ]}%
 \@x{\@s{35.70} \.{\land} MessageBox \.{=} [ p \.{\in} ProcessID \.{\mapsto}
 {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Finds the highest \ensuremath{ID} that is not dead.
}%
\@xx{}%
\@x{ MaxAliveID \.{\defeq} {\CHOOSE} id \.{\in} ProcessID \.{:}}%
\@x{\@s{32.8} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{44.12} State [ p ] . Condition \.{=}\@w{Dead} \.{\lor} id \.{\geq} p}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Get the next alive process
}%
\@xx{}%
\@x{ Neighbour ( p ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} AliveProcesses \.{\defeq} \{ q \.{\in} ProcessID \.{:}
 State [ q ] . Condition \.{=}\@w{Active} \}}%
\@x{\@s{16.4} \.{\IN}}%
 \@x{\@s{16.4} {\IF} p \.{=} MaxAliveID \.{\THEN} {\CHOOSE} q \.{\in}
 AliveProcesses \.{:} {\TRUE} \.{\ELSE}}%
\@x{\@s{51.73} {\CHOOSE} neighbour \.{\in} AliveProcesses \.{:}}%
\@x{\@s{94.51} \.{\land} p \.{<} neighbour}%
 \@x{\@s{94.51} \.{\land} \A\, q \.{\in} AliveProcesses \.{:} q \.{\leq} p
 \.{\lor} neighbour \.{\leq} q}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Sends a message and removes the head from the inbox. Sends message
 \ensuremath{msg} to \ensuremath{q} with \ensuremath{id} \ensuremath{id},
}%
\@xx{}%
\@x{}%
\@y{\@s{0}%
 and removes the first message from \ensuremath{p}.
}%
\@xx{}%
\@x{ SendMessageAndTailMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,}%
\@x{\@s{126.26} {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Simple \ensuremath{SendMessage}. Sends message \ensuremath{msg} to
 \ensuremath{q} with \ensuremath{id} \ensuremath{id}.
}%
\@xx{}%
\@x{ SendMessage ( q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{61.65} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Send message to \ensuremath{q} and empty message box of \ensuremath{p
}}%
\@xx{}%
\@x{ SendMessageAndEmptyMessageBox ( p ,\, q ,\, id ,\, msg ) \.{\defeq}}%
 \@x{\@s{49.19} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT} {\bang} [ q ]
 \.{=} Append ( MessageBox [ q ] ,\, {\langle} msg ,\, id {\rangle} ) ,\,
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Handle Messages
}%
\@xx{}%
\@x{ HandleMessages ( p ) \.{\defeq} \.{\LET}}%
\@x{\@s{49.19} id \.{\defeq} Head ( MessageBox [ p ] ) [ 2 ]}%
\@x{\@s{49.19} msg \.{\defeq} Head ( MessageBox [ p ] ) [ 1 ]}%
\@x{\@s{49.19} \.{\IN}}%
\@x{\@s{49.19} \.{\land} State [ p ] . Condition \.{=}\@w{Active}}%
\@y{\@s{0}%
 Only if the process is active
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} MessageBox [ p ] \.{\neq} {\langle}
 {\rangle}\@s{43.80}}%
\@y{\@s{0}%
 The message box shouldn\mbox{'}t be empty
}%
\@xx{}%
 \@x{\@s{49.19} \.{\land} \.{\lor} \.{\land} State [ id ] . Condition
 \.{=}\@w{Dead}}%
 \@x{\@s{71.42} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{71.42} \.{\land} {\UNCHANGED} State}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{PROBE}}%
\@y{\@s{0}%
 If the message is \ensuremath{PROBE
}}%
\@xx{}%
 \@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} State [ p ] . Participating \.{=}
 {\FALSE}}%
\@y{\@s{0}%
 Make sure the participation status is \ensuremath{{\TRUE}
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} State [ p ] . Participating \.{=} {\TRUE}}%
\@x{\@s{93.64} \.{\land} {\UNCHANGED} State}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{=} id}, send \ensuremath{SELECTED
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, p ,\,\@w{SELECTED} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id\@s{4.1} \.{\land} State [ p ] .
 Participating \.{=} {\FALSE}}%
\@y{\@s{0}%
 If \ensuremath{p \.{>} id} ignore message
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, p ,\,\@w{PROBE} )}%
 \@x{\@s{82.53} \.{\lor} \.{\land} p \.{>} id \.{\land} State [ p ] .
 Participating \.{=} {\TRUE}}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} Tail ( MessageBox [ p ] ) ]}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{<} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{<} id} send probe to \ensuremath{neighbour
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} SendMessageAndTailMessageBox ( p ,\, Neighbour ( p )
 ,\, id ,\,\@w{PROBE} )}%
\@x{\@s{60.31} \.{\lor} \.{\land} msg \.{=}\@w{SELECTED}}%
\@y{\@s{0}%
 If the message is \ensuremath{SELECTED
}}%
\@xx{}%
\@x{\@s{71.42} \.{\land} \.{\lor} \.{\land} p \.{\neq} id}%
\@y{\@s{0}%
 If \ensuremath{p \.{\neq} id}, then send \ensuremath{SELECTED} to
 \ensuremath{neighbour
}}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} SendMessageAndEmptyMessageBox ( p ,\, Neighbour ( p
 ) ,\, id ,\,\@w{SELECTED} )}%
\@x{\@s{82.53} \.{\lor} \.{\land} p \.{=} id}%
\@y{\@s{0}%
 if \ensuremath{p \.{=} id} then declare itself the leader
}%
\@xx{}%
 \@x{\@s{93.64} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} id ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
 \@x{\@s{93.64} \.{\land} MessageBox \.{'} \.{=} [ MessageBox {\EXCEPT}
 {\bang} [ p ] \.{=} {\langle} {\rangle} ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 If the leader is dead, send a \ensuremath{PROBE} message, if the only alive
 process is the first one,
}%
\@xx{}%
\@x{}%
\@y{\@s{0}%
 then make \ensuremath{p} the process, end the election and go into deadlock
}%
\@xx{}%
 \@x{ CheckLeader ( p ) \.{\defeq} \.{\land} State [ p ] . Condition
 \.{=}\@w{Active}}%
 \@x{\@s{87.92} \.{\land} State [ State [ p ] . Leader ] . Condition
 \.{=}\@w{Dead}}%
\@x{\@s{87.92} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
\@x{\@s{87.92} \.{\land} \.{\lor} \.{\land} MaxAliveID \.{=} 1}%
 \@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Leader \.{=} p ,\, {\bang} [ p ] . Participating \.{=} {\FALSE} ]}%
\@x{\@s{110.15} \.{\land} {\UNCHANGED} MessageBox}%
\@x{\@s{99.04} \.{\lor} \.{\land} MaxAliveID \.{\neq} 1}%
 \@x{\@s{110.15} \.{\land} SendMessage ( Neighbour ( p ) ,\, p ,\,\@w{PROBE}
 )}%
 \@x{\@s{110.15} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [ p ] .
 Participating \.{=} {\TRUE} ]}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Makes sure the algorithm runs correctly
}%
\@xx{}%
\@x{ KillLeader \.{\defeq}}%
\@x{\@s{12.29} \.{\land} State [ MaxAliveID ] . Leader \.{=} MaxAliveID}%
 \@x{\@s{12.29} \.{\land} State \.{'} \.{=} [ State {\EXCEPT} {\bang} [
 MaxAliveID ] . Condition \.{=}\@w{Dead} ]}%
 \@x{\@s{12.29} \.{\land} Cardinality ( \{ p \.{\in} ProcessID \.{:} State [ p
 ] . Condition \.{=}\@w{Active} \} ) \.{\geq} 2}%
\@x{\@s{12.29} \.{\land} {\UNCHANGED} MessageBox}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} \.{\lor} KillLeader}%
 \@x{\@s{39.83} \.{\lor} \E\, p \.{\in} 1 \.{\dotdot} MaxAliveID \.{:}
 HandleMessages ( p ) \.{\lor} CheckLeader ( p )}%
\@pvspace{8.0pt}%
 \@x{ Spec\@s{1.46} \.{\defeq} Init \.{\land} {\Box} [ Next ]_{ {\langle}
 State ,\, MessageBox {\rangle}} \.{\land} {\SF}_{ {\langle} State ,\,
 MessageBox {\rangle}} ( Next )}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{%
 Invariants
}%
\@xx{}%
\@pvspace{8.0pt}%
\@x{ TypeOK \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{41.35} \.{\land} State [ p ] . ID \.{\in} ProcessID}%
 \@x{\@s{41.35} \.{\land} State [ p ] . Condition \.{\in} \{\@w{Active}
 ,\,\@w{Dead} \}}%
\@x{\@s{41.35} \.{\land} State [ p ] . Leader \.{\in} ProcessID}%
\@x{\@s{41.35} \.{\land} State [ p ] . Participating \.{\in} {\BOOLEAN}}%
 \@x{\@s{41.35} \.{\land} MessageBox \.{\in} [ ProcessID \.{\rightarrow} Seq (
 Message ) ]}%
\@pvspace{8.0pt}%
 \@x{ UniqueID \.{\defeq} \A\, p ,\, q \.{\in} ProcessID \.{:} ( State [ p ] .
 ID \.{=} State [ q ] . ID ) \.{\implies} ( p \.{=} q )}%
\@pvspace{8.0pt}%
\@x{}\midbar\@xx{}%
\@x{}%
\@y{%
 Properties
}%
\@xx{}%
\@pvspace{8.0pt}%
 \@x{ ElectionTerminationImpliesSameLeader \.{\defeq} \A\, p ,\, q \.{\in}
 ProcessID \.{:}}%
\@x{\@s{16.4} ( State [ p ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ q ] . Condition \.{=}\@w{Active}}%
\@x{\@s{16.4} \.{\land} State [ p ] . Participating \.{=} {\FALSE}}%
 \@x{\@s{16.4} \.{\land} State [ q ] . Participating\@s{0.25} \.{=} {\FALSE}
 )}%
 \@x{\@s{16.4} \.{\implies} ( State [ p ] . Leader \.{=} State [ q ] . Leader
 )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 Eventually, the election will end
}%
\@xx{}%
 \@x{ ElectionWillEnd \.{\defeq} \A\, p \.{\in} ProcessID \.{:} State [ p ] .
 Participating \.{\leadsto} ( {\Diamond} ( State [ p ] . Participating \.{=}
 {\FALSE} ) )}%
\@pvspace{8.0pt}%
\@x{ HighestAliveProcessIsLeader \.{\defeq} \A\, p \.{\in} ProcessID \.{:}}%
\@x{\@s{16.4} State [ p ] . Participating \.{=} {\FALSE} \.{\implies}}%
 \@x{\@s{28.69} ( State [ MaxAliveID ] . Condition \.{=}\@w{Active}
 \.{\implies} State [ p ] . Leader \.{=} MaxAliveID )}%
\@pvspace{8.0pt}%
\@x{}\bottombar\@xx{}%


\end{document}
